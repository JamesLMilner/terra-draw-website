{"version":3,"sources":["webpack:///./ts/generic/geometry.ts","webpack:///./ts/geojson/geometry.ts","webpack:///./ts/generic/feature.ts","webpack:///./ts/geojson/feature.ts","webpack:///../node_modules/slice-source/concat.js","webpack:///../node_modules/slice-source/index.js","webpack:///./ts/header-meta.ts","webpack:///./ts/packedrtree.ts","webpack:///./ts/generic/header.ts","webpack:///./ts/generic/featurecollection.ts","webpack:///./ts/constants.ts","webpack:///./ts/geojson/featurecollection.ts","webpack:///./ts/geojson.ts","webpack:///./ts/flat-geobuf/geometry-type.ts","webpack:///../node_modules/flatbuffers/mjs/constants.js","webpack:///../node_modules/flatbuffers/mjs/encoding.js","webpack:///../node_modules/flatbuffers/mjs/utils.js","webpack:///../node_modules/flatbuffers/mjs/byte-buffer.js","webpack:///./ts/flat-geobuf/column-type.ts","webpack:///../node_modules/flatbuffers/mjs/builder.js","webpack:///./ts/flat-geobuf/geometry.ts","webpack:///./ts/flat-geobuf/column.ts","webpack:///./ts/flat-geobuf/feature.ts","webpack:///../node_modules/slice-source/empty.js","webpack:///../node_modules/slice-source/read.js","webpack:///../node_modules/slice-source/slice.js","webpack:///../node_modules/slice-source/cancel.js","webpack:///./ts/flat-geobuf/crs.ts","webpack:///./ts/flat-geobuf/header.ts","webpack:///./ts/config.ts","webpack:///./ts/http-reader.ts"],"names":["buildGeometry","builder","parsedGeometry","zOffset","endsOffset","xy","z","ends","parts","type","partOffsets","map","part","partsOffset","Geometry","createPartsVector","startGeometry","addParts","addType","endGeometry","xyOffset","createXyVector","createZVector","createEndsVector","addEnds","addXy","addZ","flat","a","length","Array","isArray","sa","push","pairFlatCoordinates","newArray","i","toGeometryType","name","t","e","GeometryType","Unknown","parseGeometry","geometry","cs","coordinates","end","css","c","geometries","undefined","parseGC","g","fromGeometry","headerType","GeometryCollection","partsLength","partType","MultiPolygon","Polygon","toGeoJsonCoordinates","xyArray","zArray","Point","from","MultiPoint","LineString","MultiLineString","extractParts","zSlices","s","xySlices","slice","endsArray","buildFeature","properties","header","columns","flatbuffers","offset","capacity","bytes","Uint8Array","view","DataView","buffer","prep","size","newBytes","Math","max","set","column","value","setUint16","ColumnType","Bool","setUint8","Short","setInt16","UShort","Int","setInt32","UInt","setUint32","Long","setBigInt64","BigInt","Float","setFloat32","Double","setFloat64","DateTime","String","str","textEncoder","encode","Json","JSON","stringify","Error","propertiesOffset","Feature","createPropertiesVector","geometryOffset","startFeature","addGeometry","addProperties","featureOffset","endFeature","finishSizePrefixed","asUint8Array","parseProperties","feature","array","propertiesArray","byteOffset","propertiesLength","getUint16","getUint8","Byte","getInt8","UByte","getInt16","getInt32","getUint32","Number","getBigInt64","ULong","getBigUint64","getFloat32","getFloat64","textDecoder","decode","subarray","parse","fromFeature","geometryType","concat","b","source","SliceSource","read","getReader","this","_source","_array","empty","_index","fromByteBuffer","bb","Header","getRootAsHeader","featuresCount","indexNodeSize","j","columnsLength","title","description","width","precision","scale","nullable","unique","primary_key","primaryKey","crs","crsMeta","org","code","wkt","code_string","codeString","envelope","metadata","calcTreeSize","numItems","nodeSize","min","n","numNodes","ceil","generateLevelBounds","levelNumNodes","levelOffsets","levelBounds","rect","readNode","NodeRange","constructor","nodes","level","_level","startNodeIdx","endNodeIdx","extendEndNodeIdx","newIdx","toString","minX","minY","maxX","maxY","firstLeafNodeIdx","queue","nodeRange","shift","nodeRangeStartIdx","isLeafNode","nodeRangeEndIdx","levelBound","nodeIdx","numNodesInRange","dataView","nodeIdxInDataView","dataViewByteStart","featureLength","nextOffset","featureIdx","extraRequestThresholdNodes","Config","global","extraRequestThreshold","nearestNodeRange","firstChildNodeIdx","newNodeRange","inferGeometryType","features","f","gtype","getGeometry","getType","deserialize","headerMetaFn","every","v","magicbytes","headerLength","readUint32","setPosition","headerMeta","getRootAsFeature","stream","reader","treeSize","readFeature","deserializeFiltered","url","nocache","HttpReader","open","selectBbox","byteLength","bytesAligned","buildHeader","crsOffset","crsCode","columnOffsets","createColumnsVector","nameOffset","createString","Column","startColumn","addName","endColumn","Crs","startCrs","addCode","endCrs","startHeader","addCrs","addFeaturesCount","addGeometryType","addIndexNodeSize","addColumns","endHeader","mapColumn","k","valueToType","serialize","featurecollection","introspectHeaderMeta","Object","keys","featuresLength","reduce","uint8","genericDeserialize","deserializeStream","genericDeserializeStream","genericDeserializeFiltered","geojson","fcSerialize","input","fcDeserialize","ReadableStream","fcDeserializeStream","fcDeserializeFiltered","Encoding","int32","Int32Array","float32","Float32Array","float64","Float64Array","isLittleEndian","Uint16Array","ByteBuffer","bytes_","position_","text_decoder_","TextDecoder","byte_size","position","readUint8","readUint16","readInt32","asIntN","asUintN","writeInt32","writeUint32","result","fromCharCode","readInt8","bb_pos","vtable_offset","vtable","readInt16","opt_encoding","utf8bytes","UTF8_BYTES","o","__string","__union","ident","charCodeAt","listAccessor","listLength","ret","val","unpack","Builder","opt_initial_size","initial_size","minalign","vtable_in_use","isNested","object_start","vtables","vector_num_elems","force_defaults","string_maps","text_encoder","TextEncoder","allocate","space","old_buf_size","new_buf_size","nbb","clear","forceDefaults","additional_bytes","align_size","growByteBuffer","pad","writeInt8","writeInt16","writeInt64","writeFloat32","writeFloat64","voffset","defaultValue","addInt8","slot","addInt16","addInt32","addInt64","addFloat32","addFloat64","addOffset","nested","obj","TypeError","numfields","notNested","vtableloc","trimmed_size","len","existing_vtable","vt1","outer_loop","vt2","root_table","opt_file_identifier","opt_size_prefix","size_prefix","file_identifier","SIZEOF_INT","FILE_IDENTIFIER_LENGTH","finish","table","field","table_start","vtable_start","elem_size","num_elems","alignment","Map","has","get","utf8","startVector","endVector","pack","list","createObjectOffset","startFunc","createObjectOffsetList","reverse","__init","startObject","addFieldOffset","data","numElems","mOffset","tOffset","tmOffset","addFieldInt8","endObject","addM","addT","addTm","index","__offset","__vector","endsLength","__vector_len","Uint32Array","readFloat64","xyLength","zLength","m","mLength","mArray","tLength","tArray","tm","readUint64","tmLength","__indirect","titleOffset","descriptionOffset","addFieldInt32","metadataOffset","requiredField","addTitle","addDescription","addWidth","addPrecision","addScale","addNullable","addUnique","addPrimaryKey","addMetadata","optionalEncoding","columnsOffset","prototype","that","then","done","Promise","resolve","cancel","orgOffset","wktOffset","codeStringOffset","addOrg","addWkt","addCodeString","envelopeOffset","hasZ","hasM","hasT","hasTm","addFieldInt64","addFieldInt16","envelopeLength","envelopeArray","_extraRequestThreshold","headerClient","indexLength","lengthBeforeTree","bufferedClient","offsetIntoTree","getRange","batches","currentBatch","streamSearch","searchResult","prevFeature","logUsage","promises","flatMap","batch","readFeatureBatch","Repeater","merge","lengthBeforeFeatures","buildFeatureClient","BufferedHttpRangeClient","httpClient","firstFeatureOffset","lastFeatureOffset","lastFeatureLength","featureClient","minFeatureReqLength","batchEnd","minReqLength","assumedHeaderLength","assumedBranchingFactor","ArrayBuffer","HttpRangeClient","start","purpose","bytesEverUsed","start_i","head","end_i","lengthToFetch","bytesEverFetched","split","toFixed","begin","requestsEverMade","bytesEverRequested","headers","Range","fetch","arrayBuffer"],"mappings":"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","file":"4.chunk.d33be.js","sourcesContent":["import * as flatbuffers from 'flatbuffers';\nimport { GeometryType } from '../flat-geobuf/geometry-type.js';\nimport { Geometry } from '../flat-geobuf/geometry.js';\n\nexport interface IParsedGeometry {\n    xy: number[];\n    z: number[];\n    ends: number[];\n    parts: IParsedGeometry[];\n    type: GeometryType;\n}\n\nexport interface ISimpleGeometry {\n    getFlatCoordinates?(): number[];\n    getType(): string;\n}\n\nexport interface IPolygon extends ISimpleGeometry {\n    getEnds(): number[];\n}\n\nexport interface IMultiLineString extends ISimpleGeometry {\n    getEnds(): number[];\n}\n\nexport interface IMultiPolygon extends ISimpleGeometry {\n    getEndss(): number[][];\n    getPolygons(): IPolygon[];\n}\n\nexport interface ICreateGeometry {\n    (\n        geometry: Geometry | null,\n        type: GeometryType,\n    ): ISimpleGeometry | undefined;\n}\n\nexport function buildGeometry(\n    builder: flatbuffers.Builder,\n    parsedGeometry: IParsedGeometry,\n): any {\n    const { xy, z, ends, parts, type } = parsedGeometry;\n\n    if (parts) {\n        const partOffsets = parts.map((part) => buildGeometry(builder, part));\n        const partsOffset = Geometry.createPartsVector(builder, partOffsets);\n        Geometry.startGeometry(builder);\n        Geometry.addParts(builder, partsOffset);\n        Geometry.addType(builder, type);\n        return Geometry.endGeometry(builder);\n    }\n\n    const xyOffset = Geometry.createXyVector(builder, xy);\n    let zOffset: number | undefined;\n    if (z) zOffset = Geometry.createZVector(builder, z);\n\n    let endsOffset: number | undefined;\n    if (ends) endsOffset = Geometry.createEndsVector(builder, ends);\n\n    Geometry.startGeometry(builder);\n    if (endsOffset) Geometry.addEnds(builder, endsOffset);\n    Geometry.addXy(builder, xyOffset);\n    if (zOffset) Geometry.addZ(builder, zOffset);\n    Geometry.addType(builder, type);\n    return Geometry.endGeometry(builder);\n}\n\nexport function flat(\n    a: any[],\n    xy: number[],\n    z: number[],\n): number[] | undefined {\n    if (a.length === 0) return;\n    if (Array.isArray(a[0])) {\n        for (const sa of a) flat(sa, xy, z);\n    } else {\n        if (a.length === 2) xy.push(...a);\n        else {\n            xy.push(a[0], a[1]);\n            z.push(a[2]);\n        }\n    }\n}\n\nexport function parseGeometry(\n    geometry: ISimpleGeometry,\n    headerGeomType: GeometryType,\n): IParsedGeometry {\n    let xy: number[] | undefined;\n    let ends: number[] | undefined;\n    let parts: IParsedGeometry[] | undefined;\n\n    let type = headerGeomType;\n    if (type === GeometryType.Unknown) {\n        type = toGeometryType(geometry.getType());\n    }\n\n    if (type === GeometryType.MultiLineString) {\n        if (geometry.getFlatCoordinates) xy = geometry.getFlatCoordinates();\n        const mlsEnds = (geometry as IMultiLineString).getEnds();\n        if (mlsEnds.length > 1) ends = mlsEnds.map((e) => e >> 1);\n    } else if (type === GeometryType.Polygon) {\n        if (geometry.getFlatCoordinates) xy = geometry.getFlatCoordinates();\n        const pEnds = (geometry as IPolygon).getEnds();\n        if (pEnds.length > 1) ends = pEnds.map((e) => e >> 1);\n    } else if (type === GeometryType.MultiPolygon) {\n        const mp = geometry as IMultiPolygon;\n        parts = mp\n            .getPolygons()\n            .map((p) => parseGeometry(p, GeometryType.Polygon));\n    } else {\n        if (geometry.getFlatCoordinates) xy = geometry.getFlatCoordinates();\n    }\n    return {\n        xy,\n        ends,\n        type,\n        parts,\n    } as IParsedGeometry;\n}\n\nexport function pairFlatCoordinates(\n    xy: Float64Array,\n    z?: Float64Array,\n): number[][] {\n    const newArray: number[][] = [];\n    for (let i = 0; i < xy.length; i += 2) {\n        const a = [xy[i], xy[i + 1]];\n        if (z) a.push(z[i >> 1]);\n        newArray.push(a);\n    }\n    return newArray;\n}\n\nexport function toGeometryType(name?: string): GeometryType {\n    if (!name) return GeometryType.Unknown;\n    const type: GeometryType = (GeometryType as any)[name];\n    return type;\n}\n","import { GeometryType } from '../flat-geobuf/geometry-type.js';\nimport { Geometry } from '../flat-geobuf/geometry.js';\n\nimport type {\n    Geometry as GeoJsonGeometry,\n    Point,\n    MultiPoint,\n    LineString,\n    MultiLineString,\n    Polygon,\n    MultiPolygon,\n    GeometryCollection,\n} from 'geojson';\n\nimport {\n    type IParsedGeometry,\n    flat,\n    pairFlatCoordinates,\n    toGeometryType,\n} from '../generic/geometry.js';\n\nexport interface IGeoJsonGeometry {\n    type: string;\n    coordinates: number[] | number[][] | number[][][] | number[][][][];\n    geometries?: IGeoJsonGeometry[];\n}\n\nexport function parseGeometry(\n    geometry:\n        | Point\n        | MultiPoint\n        | LineString\n        | MultiLineString\n        | Polygon\n        | MultiPolygon,\n): IParsedGeometry {\n    const cs = geometry.coordinates;\n    const xy: number[] = [];\n    const z: number[] = [];\n    let ends: number[] | undefined;\n    let parts: IParsedGeometry[] | undefined;\n    const type: GeometryType = toGeometryType(geometry.type);\n    let end = 0;\n    switch (geometry.type) {\n        case 'Point':\n            flat(cs, xy, z);\n            break;\n        case 'MultiPoint':\n        case 'LineString':\n            flat(cs as number[][], xy, z);\n            break;\n        case 'MultiLineString':\n        case 'Polygon': {\n            const css = cs as number[][][];\n            flat(css, xy, z);\n            if (css.length > 1) ends = css.map((c) => (end += c.length));\n            break;\n        }\n        case 'MultiPolygon': {\n            const csss = cs as number[][][][];\n            const geometries = csss.map((coordinates) => ({\n                type: 'Polygon',\n                coordinates,\n            })) as Polygon[];\n            parts = geometries.map(parseGeometry);\n            break;\n        }\n    }\n    return {\n        xy,\n        z: z.length > 0 ? z : undefined,\n        ends,\n        type,\n        parts,\n    } as IParsedGeometry;\n}\n\nexport function parseGC(geometry: GeometryCollection): IParsedGeometry {\n    const type: GeometryType = toGeometryType(geometry.type);\n    const parts: IParsedGeometry[] = [];\n    for (let i = 0; i < geometry.geometries.length; i++) {\n        const g = geometry.geometries[i];\n        if (g.type === 'GeometryCollection') parts.push(parseGC(g));\n        else parts.push(parseGeometry(g));\n    }\n    return {\n        type,\n        parts,\n    } as IParsedGeometry;\n}\n\nfunction extractParts(xy: Float64Array, z: Float64Array, ends: Uint32Array) {\n    if (!ends || ends.length === 0) return [pairFlatCoordinates(xy, z)];\n    let s = 0;\n    const xySlices = Array.from(ends).map((e) => xy.slice(s, (s = e << 1)));\n    let zSlices: Float64Array[];\n    if (z) {\n        s = 0;\n        zSlices = Array.from(ends).map((e) => z.slice(s, (s = e)));\n    }\n    return xySlices.map((xy, i) =>\n        pairFlatCoordinates(xy, zSlices ? zSlices[i] : undefined),\n    );\n}\n\nfunction toGeoJsonCoordinates(geometry: Geometry, type: GeometryType) {\n    const xy = geometry.xyArray() as Float64Array;\n    const z = geometry.zArray() as Float64Array;\n    switch (type) {\n        case GeometryType.Point: {\n            const a = Array.from(xy);\n            if (z) a.push(z[0]);\n            return a;\n        }\n        case GeometryType.MultiPoint:\n        case GeometryType.LineString:\n            return pairFlatCoordinates(xy, z);\n        case GeometryType.MultiLineString:\n            return extractParts(xy, z, geometry.endsArray() as Uint32Array);\n        case GeometryType.Polygon:\n            return extractParts(xy, z, geometry.endsArray() as Uint32Array);\n    }\n}\n\nexport function fromGeometry(\n    geometry: Geometry,\n    headerType: GeometryType,\n): GeoJsonGeometry {\n    let type = headerType;\n    if (type === GeometryType.Unknown) {\n        type = geometry.type();\n    }\n    if (type === GeometryType.GeometryCollection) {\n        const geometries: GeoJsonGeometry[] = [];\n        for (let i = 0; i < geometry.partsLength(); i++) {\n            const part = geometry.parts(i) as Geometry;\n            const partType = part.type() as GeometryType;\n            geometries.push(fromGeometry(part, partType));\n        }\n        return {\n            type: GeometryType[type],\n            geometries,\n        } as GeoJsonGeometry;\n    } else if (type === GeometryType.MultiPolygon) {\n        const geometries: GeoJsonGeometry[] = [];\n        for (let i = 0; i < geometry.partsLength(); i++)\n            geometries.push(\n                fromGeometry(\n                    geometry.parts(i) as Geometry,\n                    GeometryType.Polygon,\n                ),\n            );\n        return {\n            type: GeometryType[type],\n            coordinates: geometries.map((g) => (g as Polygon).coordinates),\n        } as GeoJsonGeometry;\n    }\n    const coordinates = toGeoJsonCoordinates(geometry, type);\n    return {\n        type: GeometryType[type],\n        coordinates,\n    } as GeoJsonGeometry;\n}\n","import * as flatbuffers from 'flatbuffers';\n\nimport type ColumnMeta from '../column-meta.js';\nimport { ColumnType } from '../flat-geobuf/column-type.js';\nimport { Feature } from '../flat-geobuf/feature.js';\nimport type HeaderMeta from '../header-meta.js';\nimport {\n    buildGeometry,\n    type ISimpleGeometry,\n    type ICreateGeometry,\n    type IParsedGeometry,\n} from './geometry.js';\n\nconst textEncoder = new TextEncoder();\nconst textDecoder = new TextDecoder();\n\nexport interface IFeature {\n    getGeometry?(): ISimpleGeometry;\n    getProperties?(): any;\n    setProperties?(properties: Record<string, unknown>): any;\n}\n\nexport interface ICreateFeature {\n    (\n        geometry?: ISimpleGeometry,\n        properties?: Record<string, unknown>,\n    ): IFeature;\n}\n\nexport interface IProperties {\n    [key: string]: boolean | number | string | any;\n}\n\nexport function fromFeature(\n    feature: Feature,\n    header: HeaderMeta,\n    createGeometry: ICreateGeometry,\n    createFeature: ICreateFeature,\n): IFeature {\n    const columns = header.columns;\n    const geometry = feature.geometry();\n    const simpleGeometry = createGeometry(geometry, header.geometryType);\n    const properties = parseProperties(feature, columns as ColumnMeta[]);\n    return createFeature(simpleGeometry, properties);\n}\n\nexport function buildFeature(\n    geometry: IParsedGeometry,\n    properties: IProperties,\n    header: HeaderMeta,\n): Uint8Array {\n    const columns = header.columns;\n    const builder = new flatbuffers.Builder();\n\n    let offset = 0;\n    let capacity = 1024;\n    let bytes = new Uint8Array(capacity);\n    let view = new DataView(bytes.buffer);\n\n    const prep = function (size: number) {\n        if (offset + size < capacity) return;\n        capacity = Math.max(capacity + size, capacity * 2);\n        const newBytes = new Uint8Array(capacity);\n        newBytes.set(bytes);\n        bytes = newBytes;\n        view = new DataView(bytes.buffer);\n    };\n\n    if (columns) {\n        for (let i = 0; i < columns.length; i++) {\n            const column = columns[i];\n            const value = properties[column.name];\n            if (value === null) continue;\n            prep(2);\n            view.setUint16(offset, i, true);\n            offset += 2;\n            switch (column.type) {\n                case ColumnType.Bool:\n                    prep(1);\n                    view.setUint8(offset, value as number);\n                    offset += 1;\n                    break;\n                case ColumnType.Short:\n                    prep(2);\n                    view.setInt16(offset, value as number, true);\n                    offset += 2;\n                    break;\n                case ColumnType.UShort:\n                    prep(2);\n                    view.setUint16(offset, value as number, true);\n                    offset += 2;\n                    break;\n                case ColumnType.Int:\n                    prep(4);\n                    view.setInt32(offset, value as number, true);\n                    offset += 4;\n                    break;\n                case ColumnType.UInt:\n                    prep(4);\n                    view.setUint32(offset, value as number, true);\n                    offset += 4;\n                    break;\n                case ColumnType.Long:\n                    prep(8);\n                    view.setBigInt64(offset, BigInt(value), true);\n                    offset += 8;\n                    break;\n                case ColumnType.Float:\n                    prep(4);\n                    view.setFloat32(offset, value as number, true);\n                    offset += 4;\n                    break;\n                case ColumnType.Double:\n                    prep(8);\n                    view.setFloat64(offset, value as number, true);\n                    offset += 8;\n                    break;\n                case ColumnType.DateTime:\n                case ColumnType.String: {\n                    const str = textEncoder.encode(value);\n                    prep(4);\n                    view.setUint32(offset, str.length, true);\n                    offset += 4;\n                    prep(str.length);\n                    bytes.set(str, offset);\n                    offset += str.length;\n                    break;\n                }\n                case ColumnType.Json: {\n                    const str = textEncoder.encode(JSON.stringify(value));\n                    prep(4);\n                    view.setUint32(offset, str.length, true);\n                    offset += 4;\n                    prep(str.length);\n                    bytes.set(str, offset);\n                    offset += str.length;\n                    break;\n                }\n                default:\n                    throw new Error('Unknown type ' + column.type);\n            }\n        }\n    }\n\n    let propertiesOffset = 0;\n    if (offset > 0)\n        propertiesOffset = Feature.createPropertiesVector(\n            builder,\n            bytes.slice(0, offset),\n        );\n\n    const geometryOffset = buildGeometry(builder, geometry);\n    Feature.startFeature(builder);\n    Feature.addGeometry(builder, geometryOffset);\n    if (propertiesOffset) Feature.addProperties(builder, propertiesOffset);\n    const featureOffset = Feature.endFeature(builder);\n    builder.finishSizePrefixed(featureOffset);\n    return builder.asUint8Array() as Uint8Array;\n}\n\nexport function parseProperties(\n    feature: Feature,\n    columns?: ColumnMeta[] | null,\n): Record<string, unknown> {\n    const properties: Record<string, unknown> = {};\n    if (!columns || columns.length === 0) return properties;\n    const array = feature.propertiesArray();\n    if (!array) return properties;\n    const view = new DataView(array.buffer, array.byteOffset);\n    const length = feature.propertiesLength();\n    let offset = 0;\n    while (offset < length) {\n        const i = view.getUint16(offset, true);\n        offset += 2;\n        const column = columns[i];\n        const name = column.name;\n        switch (column.type) {\n            case ColumnType.Bool: {\n                properties[name] = !!view.getUint8(offset);\n                offset += 1;\n                break;\n            }\n            case ColumnType.Byte: {\n                properties[name] = view.getInt8(offset);\n                offset += 1;\n                break;\n            }\n            case ColumnType.UByte: {\n                properties[name] = view.getUint8(offset);\n                offset += 1;\n                break;\n            }\n            case ColumnType.Short: {\n                properties[name] = view.getInt16(offset, true);\n                offset += 2;\n                break;\n            }\n            case ColumnType.UShort: {\n                properties[name] = view.getUint16(offset, true);\n                offset += 2;\n                break;\n            }\n            case ColumnType.Int: {\n                properties[name] = view.getInt32(offset, true);\n                offset += 4;\n                break;\n            }\n            case ColumnType.UInt: {\n                properties[name] = view.getUint32(offset, true);\n                offset += 4;\n                break;\n            }\n            case ColumnType.Long: {\n                properties[name] = Number(view.getBigInt64(offset, true));\n                offset += 8;\n                break;\n            }\n            case ColumnType.ULong: {\n                properties[name] = Number(view.getBigUint64(offset, true));\n                offset += 8;\n                break;\n            }\n            case ColumnType.Float: {\n                properties[name] = view.getFloat32(offset, true);\n                offset += 4;\n                break;\n            }\n            case ColumnType.Double: {\n                properties[name] = view.getFloat64(offset, true);\n                offset += 8;\n                break;\n            }\n            case ColumnType.DateTime:\n            case ColumnType.String: {\n                const length = view.getUint32(offset, true);\n                offset += 4;\n                properties[name] = textDecoder.decode(\n                    array.subarray(offset, offset + length),\n                );\n                offset += length;\n                break;\n            }\n            case ColumnType.Json: {\n                const length = view.getUint32(offset, true);\n                offset += 4;\n                const str = textDecoder.decode(\n                    array.subarray(offset, offset + length),\n                );\n                properties[name] = JSON.parse(str);\n                offset += length;\n                break;\n            }\n            default:\n                throw new Error('Unknown type ' + column.type);\n        }\n    }\n    return properties;\n}\n","import { Feature } from '../flat-geobuf/feature.js';\nimport { Geometry } from '../flat-geobuf/geometry.js';\nimport type HeaderMeta from '../header-meta.js';\nimport { fromGeometry } from './geometry.js';\nimport { type IFeature, parseProperties } from '../generic/feature.js';\n\nimport { type Feature as GeoJsonFeature } from 'geojson';\n\nexport interface IGeoJsonFeature extends IFeature, GeoJsonFeature {}\n\nexport function fromFeature(\n    feature: Feature,\n    header: HeaderMeta,\n): IGeoJsonFeature {\n    const columns = header.columns;\n    const geometry = fromGeometry(\n        feature.geometry() as Geometry,\n        header.geometryType,\n    );\n    const geoJsonfeature: GeoJsonFeature = {\n        type: 'Feature',\n        geometry,\n        properties: parseProperties(feature, columns),\n    };\n    return geoJsonfeature;\n}\n","export default function concat(a, b) {\n  if (!a.length) return b;\n  if (!b.length) return a;\n  var c = new Uint8Array(a.length + b.length);\n  c.set(a);\n  c.set(b, a.length);\n  return c;\n}\n","import empty from \"./empty\";\nimport slice_cancel from \"./cancel\";\nimport slice_read from \"./read\";\nimport slice_slice from \"./slice\";\n\nexport default function slice(source) {\n  return typeof source.slice === \"function\" ? source :\n      new SliceSource(typeof source.read === \"function\" ? source\n          : source.getReader());\n}\n\nfunction SliceSource(source) {\n  this._source = source;\n  this._array = empty;\n  this._index = 0;\n}\n\nSliceSource.prototype.read = slice_read;\nSliceSource.prototype.slice = slice_slice;\nSliceSource.prototype.cancel = slice_cancel;\n","import * as flatbuffers from 'flatbuffers';\n\nimport type ColumnMeta from './column-meta.js';\nimport type CrsMeta from './crs-meta.js';\nimport { GeometryType } from './flat-geobuf/geometry-type.js';\nimport { Header } from './flat-geobuf/header.js';\n\nexport default interface HeaderMeta {\n    geometryType: GeometryType;\n    columns: ColumnMeta[] | null;\n    envelope: Float64Array | null;\n    featuresCount: number;\n    indexNodeSize: number;\n    crs: CrsMeta | null;\n    title: string | null;\n    description: string | null;\n    metadata: string | null;\n}\n\nexport function fromByteBuffer(bb: flatbuffers.ByteBuffer): HeaderMeta {\n    const header = Header.getRootAsHeader(bb);\n    const featuresCount = header.featuresCount();\n    const indexNodeSize = header.indexNodeSize();\n\n    const columns: ColumnMeta[] = [];\n    for (let j = 0; j < header.columnsLength(); j++) {\n        const column = header.columns(j);\n        if (!column) throw new Error('Column unexpectedly missing');\n        if (!column.name()) throw new Error('Column name unexpectedly missing');\n        columns.push({\n            name: column.name() as string,\n            type: column.type(),\n            title: column.title(),\n            description: column.description(),\n            width: column.width(),\n            precision: column.precision(),\n            scale: column.scale(),\n            nullable: column.nullable(),\n            unique: column.unique(),\n            primary_key: column.primaryKey(),\n        });\n    }\n    const crs = header.crs();\n    const crsMeta: CrsMeta | null = crs\n        ? {\n              org: crs.org(),\n              code: crs.code(),\n              name: crs.name(),\n              description: crs.description(),\n              wkt: crs.wkt(),\n              code_string: crs.codeString(),\n          }\n        : null;\n    const headerMeta: HeaderMeta = {\n        geometryType: header.geometryType(),\n        columns: columns,\n        envelope: null,\n        featuresCount: Number(featuresCount),\n        indexNodeSize: indexNodeSize,\n        crs: crsMeta,\n        title: header.title(),\n        description: header.description(),\n        metadata: header.metadata(),\n    };\n    return headerMeta;\n}\n","import Config from './config.js';\n\nexport const NODE_ITEM_BYTE_LEN: number = 8 * 4 + 8;\n/**\n * @deprecated Use `NODE_ITEM_BYTE_LEN` instead.\n */\nexport const NODE_ITEM_LEN = NODE_ITEM_BYTE_LEN;\n\n// default branching factor of a node in the rtree\n//\n// actual value will be specified in the header but\n// this can be useful for having reasonably sized guesses for fetch-sizes when\n// streaming results\nexport const DEFAULT_NODE_SIZE = 16;\n\nexport interface Rect {\n    minX: number;\n    minY: number;\n    maxX: number;\n    maxY: number;\n}\n\nexport function calcTreeSize(numItems: number, nodeSize: number): number {\n    nodeSize = Math.min(Math.max(+nodeSize, 2), 65535);\n    let n = numItems;\n    let numNodes = n;\n    do {\n        n = Math.ceil(n / nodeSize);\n        numNodes += n;\n    } while (n !== 1);\n    return numNodes * NODE_ITEM_BYTE_LEN;\n}\n\n/**\n * returns [levelOffset, numNodes] for each level\n */\nexport function generateLevelBounds(\n    numItems: number,\n    nodeSize: number,\n): Array<[number, number]> {\n    if (nodeSize < 2) throw new Error('Node size must be at least 2');\n    if (numItems === 0)\n        throw new Error('Number of items must be greater than 0');\n\n    // number of nodes per level in bottom-up order\n    let n = numItems;\n    let numNodes = n;\n    const levelNumNodes = [n];\n    do {\n        n = Math.ceil(n / nodeSize);\n        numNodes += n;\n        levelNumNodes.push(n);\n    } while (n !== 1);\n\n    // bounds per level in reversed storage order (top-down)\n    const levelOffsets: Array<number> = [];\n    n = numNodes;\n    for (const size of levelNumNodes) {\n        levelOffsets.push(n - size);\n        n -= size;\n    }\n    const levelBounds: Array<[number, number]> = [];\n    for (let i = 0; i < levelNumNodes.length; i++)\n        levelBounds.push([levelOffsets[i], levelOffsets[i] + levelNumNodes[i]]);\n    return levelBounds;\n}\n\ntype ReadNodeFn = (treeOffset: number, size: number) => Promise<ArrayBuffer>;\n\n/**\n * A feature found to be within the bounding box `rect`\n *\n *  (offset, index)\n *  `offset`: Byte offset in feature data section\n *  `index`: feature number\n *  `featureLength`: featureLength, except for the last element\n */\nexport type SearchResult = [number, number, number | null];\n\n/**\n * Yield's a `SearchResult` for each feature within the bounds of `rect`.\n *\n * Every node in the FGB index tree has a bounding rect, all of the nodes children\n * are contained within that bounding rect. The leaf nodes of the tree represent\n * the features of the collection.\n *\n * As we traverse the tree, starting from the root, we'll need to read more data\n * from the index. When we don't already have this range data buffered locally,\n * an HTTP fetch is triggered. For performance, we merge adjacent and nearby\n * request ranges into a single request, reasoning that fetching a few extra\n * bytes is a good tradeoff if it means we can reduce the number of requests.\n */\nexport async function* streamSearch(\n    numItems: number,\n    nodeSize: number,\n    rect: Rect,\n    readNode: ReadNodeFn,\n): AsyncGenerator<SearchResult, void, unknown> {\n    type NodeIdx = number;\n    class NodeRange {\n        _level: number;\n        nodes: [NodeIdx, NodeIdx];\n        constructor(nodes: [NodeIdx, NodeIdx], level: number) {\n            this._level = level;\n            this.nodes = nodes;\n        }\n\n        level(): number {\n            return this._level;\n        }\n\n        startNodeIdx(): NodeIdx {\n            return this.nodes[0];\n        }\n\n        endNodeIdx(): NodeIdx {\n            return this.nodes[1];\n        }\n\n        extendEndNodeIdx(newIdx: number) {\n            console.assert(newIdx > this.nodes[1]);\n            this.nodes[1] = newIdx;\n        }\n\n        toString(): string {\n            return `[NodeRange level: ${this._level}, nodes: ${this.nodes[0]}-${this.nodes[1]}]`;\n        }\n    }\n\n    const { minX, minY, maxX, maxY } = rect;\n    console.info(`tree items: ${numItems}, nodeSize: ${nodeSize}`);\n    const levelBounds = generateLevelBounds(numItems, nodeSize);\n    const firstLeafNodeIdx = levelBounds[0][0];\n\n    const rootNodeRange: NodeRange = (() => {\n        const range: [number, number] = [0, 1];\n        const level = levelBounds.length - 1;\n        return new NodeRange(range, level);\n    })();\n\n    const queue: Array<NodeRange> = [rootNodeRange];\n\n    console.debug(\n        `starting stream search with queue: ${queue}, numItems: ${numItems}, nodeSize: ${nodeSize}, levelBounds: ${levelBounds}`,\n    );\n\n    while (queue.length != 0) {\n        const nodeRange = queue.shift()!;\n\n        console.debug(\n            `popped node: ${nodeRange}, queueLength: ${queue.length}`,\n        );\n\n        const nodeRangeStartIdx = nodeRange.startNodeIdx();\n        const isLeafNode = nodeRangeStartIdx >= firstLeafNodeIdx;\n\n        // find the end index of the node\n        const nodeRangeEndIdx = (() => {\n            const [, levelBound] = levelBounds[nodeRange.level()];\n            const nodeIdx = Math.min(\n                nodeRange.endNodeIdx() + nodeSize,\n                levelBound,\n            );\n\n            if (isLeafNode && nodeIdx < levelBound) {\n                // We can infer the length of *this* feature by getting the start of the *next*\n                // feature, so we get an extra node.\n                // This approach doesn't work for the final node in the index,\n                // but in that case we know that the feature runs to the end of the FGB file and\n                // could make an open ended range request to get \"the rest of the data\".\n                return nodeIdx + 1;\n            } else {\n                return nodeIdx;\n            }\n        })();\n\n        const numNodesInRange = nodeRangeEndIdx - nodeRangeStartIdx;\n\n        const buffer = await readNode(\n            nodeRangeStartIdx * NODE_ITEM_BYTE_LEN,\n            numNodesInRange * NODE_ITEM_BYTE_LEN,\n        );\n\n        const dataView = new DataView(buffer);\n        for (\n            let nodeIdx = nodeRangeStartIdx;\n            nodeIdx < nodeRangeEndIdx;\n            nodeIdx++\n        ) {\n            const nodeIdxInDataView = nodeIdx - nodeRangeStartIdx;\n            const dataViewByteStart = nodeIdxInDataView * NODE_ITEM_BYTE_LEN;\n            if (maxX < dataView.getFloat64(dataViewByteStart + 0, true))\n                continue; // maxX < nodeMinX\n            if (maxY < dataView.getFloat64(dataViewByteStart + 8, true))\n                continue; // maxY < nodeMinY\n            if (minX > dataView.getFloat64(dataViewByteStart + 16, true))\n                continue; // minX > nodeMaxX\n            if (minY > dataView.getFloat64(dataViewByteStart + 24, true))\n                continue; // minY > nodeMaxY\n\n            // `offset` is:\n            // For leaf nodes: the byte-offset into the feature buffer.\n            // For inner nodes: the node-idx of its first child.\n            const offset = dataView.getBigUint64(dataViewByteStart + 32, true);\n\n            if (isLeafNode) {\n                const featureByteOffset = offset;\n                const featureLength = (() => {\n                    if (nodeIdx < numItems - 1) {\n                        // Since features are tightly packed, we infer the\n                        // length of _this_ feature by measuring to the _next_\n                        // feature's start.\n                        const nextPos =\n                            (nodeIdxInDataView + 1) * NODE_ITEM_BYTE_LEN;\n                        // console.debug(`nodeIdx: ${nodeIdx} of ${numItems}, nodeRangeStartIdx: ${nodeRangeStartIdx}, nextPos: ${nextPos}, dataView.byteLength: ${dataView.byteLength}`,);\n                        const nextOffset = dataView.getBigUint64(\n                            nextPos + 32,\n                            true,\n                        );\n                        return nextOffset - featureByteOffset;\n                    } else {\n                        // This is the last feature - there's no \"next\" feature\n                        // to measure to, so we can't know it's length.\n                        return null;\n                    }\n                })();\n\n                const featureIdx = nodeIdx - firstLeafNodeIdx;\n                yield [\n                    Number(featureByteOffset),\n                    featureIdx,\n                    Number(featureLength),\n                ];\n                continue;\n            }\n\n            const firstChildNodeIdx = offset;\n\n            // request up to this many nodes if it means we can eliminate an\n            // extra request\n            const extraRequestThresholdNodes =\n                Config.global.extraRequestThreshold() / NODE_ITEM_BYTE_LEN;\n\n            // Since we're traversing the tree by monotonically increasing byte\n            // offset, the most recently enqueued node range will be the\n            // nearest, and thus presents the best candidate for merging.\n            const nearestNodeRange = queue[queue.length - 1];\n            if (\n                nearestNodeRange !== undefined &&\n                nearestNodeRange.level() == nodeRange.level() - 1 &&\n                firstChildNodeIdx <\n                    nearestNodeRange.endNodeIdx() + extraRequestThresholdNodes\n            ) {\n                console.debug(\n                    `Merging \"nodeRange\" request into existing range: ${nearestNodeRange}, newEndNodeIdx: ${nearestNodeRange.endNodeIdx()} -> ${firstChildNodeIdx}`,\n                );\n                nearestNodeRange.extendEndNodeIdx(Number(firstChildNodeIdx));\n                continue;\n            }\n\n            const newNodeRange: NodeRange = (() => {\n                const level = nodeRange.level() - 1;\n                const range: [number, number] = [\n                    Number(firstChildNodeIdx),\n                    Number(firstChildNodeIdx) + 1,\n                ];\n                return new NodeRange(range, level);\n            })();\n\n            // We're going to add a new node range - log the reason\n            if (\n                nearestNodeRange !== undefined &&\n                nearestNodeRange.level() == newNodeRange.level()\n            ) {\n                console.info(\n                    `Same level, but too far away. Pushing new request for nodeIdx: ${firstChildNodeIdx} rather than merging with distant ${nearestNodeRange}`,\n                );\n            } else {\n                console.info(\n                    `Pushing new level for ${newNodeRange} onto queue with nearestNodeRange: ${nearestNodeRange} since there's not already a range for this level.`,\n                );\n            }\n\n            queue.push(newNodeRange);\n        }\n    }\n}\n","import { GeometryType } from '../flat-geobuf/geometry-type.js';\nimport { toGeometryType } from '../generic/geometry.js';\nimport { type IFeature } from './feature.js';\nimport { type IGeoJsonFeature } from '../geojson/feature.js';\n\nfunction featureGeomType(feature: IFeature | IGeoJsonFeature): GeometryType {\n    if (feature.getGeometry) {\n        return toGeometryType(feature.getGeometry().getType());\n    } else {\n        return toGeometryType((feature as IGeoJsonFeature).geometry.type);\n    }\n}\n\nexport function inferGeometryType(\n    features: (IFeature | IGeoJsonFeature)[],\n): GeometryType {\n    let geometryType: GeometryType | undefined = undefined;\n\n    for (const f of features) {\n        if (geometryType === GeometryType.Unknown) {\n            break;\n        }\n\n        const gtype = featureGeomType(f);\n        if (geometryType === undefined) {\n            geometryType = gtype;\n        } else if (geometryType !== gtype) {\n            geometryType = GeometryType.Unknown;\n        }\n    }\n    if (geometryType === undefined) {\n        throw new Error(\n            'Could not infer geometry type for collection of features.',\n        );\n    }\n    return geometryType;\n}\n","import * as flatbuffers from 'flatbuffers';\nimport slice from 'slice-source';\n\nimport type ColumnMeta from '../column-meta.js';\n\nimport { Header } from '../flat-geobuf/header.js';\n\nimport { Column } from '../flat-geobuf/column.js';\nimport { ColumnType } from '../flat-geobuf/column-type.js';\nimport { Feature } from '../flat-geobuf/feature.js';\nimport type HeaderMeta from '../header-meta.js';\nimport { fromByteBuffer } from '../header-meta.js';\n\nimport { buildFeature, type IFeature } from './feature.js';\nimport { HttpReader } from '../http-reader.js';\nimport { type Rect, calcTreeSize } from '../packedrtree.js';\nimport { parseGeometry } from './geometry.js';\nimport { type HeaderMetaFn } from '../generic.js';\nimport { magicbytes, SIZE_PREFIX_LEN } from '../constants.js';\nimport { inferGeometryType } from './header.js';\nimport { Crs } from '../flat-geobuf/crs.js';\n\nexport type FromFeatureFn = (feature: Feature, header: HeaderMeta) => IFeature;\ntype ReadFn = (size: number, purpose: string) => Promise<ArrayBuffer>;\n\n/**\n * Serialize generic features to FlatGeobuf\n * @param features\n */\nexport function serialize(features: IFeature[]): Uint8Array {\n    const headerMeta = introspectHeaderMeta(features);\n    const header = buildHeader(headerMeta);\n    const featureBuffers: Uint8Array[] = features.map((f) => {\n        if (!f.getGeometry)\n            throw new Error('Missing getGeometry implementation');\n        if (!f.getProperties)\n            throw new Error('Missing getProperties implementation');\n        return buildFeature(\n            parseGeometry(f.getGeometry(), headerMeta.geometryType),\n            f.getProperties(),\n            headerMeta,\n        );\n    });\n    const featuresLength = featureBuffers\n        .map((f) => f.length)\n        .reduce((a, b) => a + b);\n    const uint8 = new Uint8Array(\n        magicbytes.length + header.length + featuresLength,\n    );\n    uint8.set(header, magicbytes.length);\n    let offset = magicbytes.length + header.length;\n    for (const feature of featureBuffers) {\n        uint8.set(feature, offset);\n        offset += feature.length;\n    }\n    uint8.set(magicbytes);\n    return uint8;\n}\n\nexport function deserialize(\n    bytes: Uint8Array,\n    fromFeature: FromFeatureFn,\n    headerMetaFn?: HeaderMetaFn,\n): IFeature[] {\n    if (!bytes.subarray(0, 3).every((v, i) => magicbytes[i] === v))\n        throw new Error('Not a FlatGeobuf file');\n\n    const bb = new flatbuffers.ByteBuffer(bytes);\n    const headerLength = bb.readUint32(magicbytes.length);\n    bb.setPosition(magicbytes.length + SIZE_PREFIX_LEN);\n\n    const headerMeta = fromByteBuffer(bb);\n    if (headerMetaFn) headerMetaFn(headerMeta);\n\n    let offset = magicbytes.length + SIZE_PREFIX_LEN + headerLength;\n\n    const { indexNodeSize, featuresCount } = headerMeta;\n    if (indexNodeSize > 0) offset += calcTreeSize(featuresCount, indexNodeSize);\n\n    const features: IFeature[] = [];\n    while (offset < bb.capacity()) {\n        const featureLength = bb.readUint32(offset);\n        bb.setPosition(offset + SIZE_PREFIX_LEN);\n        const feature = Feature.getRootAsFeature(bb);\n        features.push(fromFeature(feature, headerMeta));\n        offset += SIZE_PREFIX_LEN + featureLength;\n    }\n\n    return features;\n}\n\nexport async function* deserializeStream(\n    stream: ReadableStream,\n    fromFeature: FromFeatureFn,\n    headerMetaFn?: HeaderMetaFn,\n): AsyncGenerator<IFeature> {\n    const reader = slice(stream);\n    const read: ReadFn = async (size) => await reader.slice(size);\n\n    let bytes = new Uint8Array(await read(8, 'magic bytes'));\n    if (!bytes.subarray(0, 3).every((v, i) => magicbytes[i] === v))\n        throw new Error('Not a FlatGeobuf file');\n    bytes = new Uint8Array(await read(4, 'header length'));\n    let bb = new flatbuffers.ByteBuffer(bytes);\n    const headerLength = bb.readUint32(0);\n    bytes = new Uint8Array(await read(headerLength, 'header data'));\n    bb = new flatbuffers.ByteBuffer(bytes);\n\n    const headerMeta = fromByteBuffer(bb);\n    if (headerMetaFn) headerMetaFn(headerMeta);\n\n    const { indexNodeSize, featuresCount } = headerMeta;\n    if (indexNodeSize > 0) {\n        const treeSize = calcTreeSize(featuresCount, indexNodeSize);\n        await read(treeSize, 'entire index, w/o rect');\n    }\n    let feature: IFeature | undefined;\n    while ((feature = await readFeature(read, headerMeta, fromFeature)))\n        yield feature;\n}\n\nexport async function* deserializeFiltered(\n    url: string,\n    rect: Rect,\n    fromFeature: FromFeatureFn,\n    headerMetaFn?: HeaderMetaFn,\n    nocache: boolean = false,\n): AsyncGenerator<IFeature> {\n    const reader = await HttpReader.open(url, nocache);\n    console.debug('opened reader');\n    if (headerMetaFn) headerMetaFn(reader.header);\n\n    for await (const feature of reader.selectBbox(rect)) {\n        yield fromFeature(feature, reader.header);\n    }\n}\n\nasync function readFeature(\n    read: ReadFn,\n    headerMeta: HeaderMeta,\n    fromFeature: FromFeatureFn,\n): Promise<IFeature | undefined> {\n    let bytes = new Uint8Array(await read(4, 'feature length'));\n    if (bytes.byteLength === 0) return;\n    let bb = new flatbuffers.ByteBuffer(bytes);\n    const featureLength = bb.readUint32(0);\n    bytes = new Uint8Array(await read(featureLength, 'feature data'));\n    const bytesAligned = new Uint8Array(featureLength + 4);\n    bytesAligned.set(bytes, 4);\n    bb = new flatbuffers.ByteBuffer(bytesAligned);\n    bb.setPosition(SIZE_PREFIX_LEN);\n    const feature = Feature.getRootAsFeature(bb);\n    return fromFeature(feature, headerMeta);\n}\n\nfunction buildColumn(builder: flatbuffers.Builder, column: ColumnMeta): number {\n    const nameOffset = builder.createString(column.name);\n    Column.startColumn(builder);\n    Column.addName(builder, nameOffset);\n    Column.addType(builder, column.type);\n    return Column.endColumn(builder);\n}\n\nexport function buildHeader(\n    header: HeaderMeta,\n    crsCode: number = 0,\n): Uint8Array {\n    const builder = new flatbuffers.Builder();\n\n    let columnOffsets = 0;\n    if (header.columns)\n        columnOffsets = Header.createColumnsVector(\n            builder,\n            header.columns.map((c) => buildColumn(builder, c)),\n        );\n\n    const nameOffset = builder.createString('L1');\n\n    let crsOffset;\n    if (crsCode) {\n        Crs.startCrs(builder);\n        Crs.addCode(builder, crsCode);\n        crsOffset = Crs.endCrs(builder);\n    }\n    Header.startHeader(builder);\n    if (crsOffset) Header.addCrs(builder, crsOffset);\n    Header.addFeaturesCount(builder, BigInt(header.featuresCount));\n    Header.addGeometryType(builder, header.geometryType);\n    Header.addIndexNodeSize(builder, 0);\n    if (columnOffsets) Header.addColumns(builder, columnOffsets);\n    Header.addName(builder, nameOffset);\n    const offset = Header.endHeader(builder);\n    builder.finishSizePrefixed(offset);\n    return builder.asUint8Array() as Uint8Array;\n}\n\nfunction valueToType(value: boolean | number | string): ColumnType {\n    if (typeof value === 'boolean') return ColumnType.Bool;\n    else if (typeof value === 'number')\n        if (value % 1 === 0) return ColumnType.Int;\n        else return ColumnType.Double;\n    else if (typeof value === 'string') return ColumnType.String;\n    else if (value === null) return ColumnType.String;\n    else if (typeof value === 'object') return ColumnType.Json;\n    else throw new Error(`Unknown type (value '${value}')`);\n}\n\nexport function mapColumn(properties: any, k: string): ColumnMeta {\n    return {\n        name: k,\n        type: valueToType(properties[k]),\n        title: null,\n        description: null,\n        width: -1,\n        precision: -1,\n        scale: -1,\n        nullable: true,\n        unique: false,\n        primary_key: false,\n    };\n}\n\nfunction introspectHeaderMeta(features: IFeature[]): HeaderMeta {\n    const sampleFeature = features[0];\n    const properties = sampleFeature.getProperties\n        ? sampleFeature.getProperties()\n        : {};\n\n    let columns: ColumnMeta[] | null = null;\n    if (properties)\n        columns = Object.keys(properties)\n            .filter((key) => key !== 'geometry')\n            .map((k) => mapColumn(properties, k));\n\n    const geometryType = inferGeometryType(features);\n    const headerMeta: HeaderMeta = {\n        geometryType,\n        columns,\n        envelope: null,\n        featuresCount: features.length,\n        indexNodeSize: 0,\n        crs: null,\n        title: null,\n        description: null,\n        metadata: null,\n    };\n    return headerMeta;\n}\n","export const magicbytes: Uint8Array = new Uint8Array([\n    0x66, 0x67, 0x62, 0x03, 0x66, 0x67, 0x62, 0x00,\n]);\nexport const SIZE_PREFIX_LEN = 4;\n","import type ColumnMeta from '../column-meta.js';\nimport type HeaderMeta from '../header-meta.js';\n\nimport { fromFeature } from './feature.js';\nimport { parseGeometry, parseGC } from './geometry.js';\nimport {\n    buildHeader,\n    deserialize as genericDeserialize,\n    deserializeStream as genericDeserializeStream,\n    deserializeFiltered as genericDeserializeFiltered,\n    mapColumn,\n} from '../generic/featurecollection.js';\nimport { type Rect } from '../packedrtree.js';\nimport { buildFeature, type IProperties } from '../generic/feature.js';\nimport { type HeaderMetaFn } from '../generic.js';\nimport { magicbytes } from '../constants.js';\nimport { inferGeometryType } from '../generic/header.js';\n\nimport type {\n    FeatureCollection as GeoJsonFeatureCollection,\n    Point,\n    MultiPoint,\n    LineString,\n    MultiLineString,\n    Polygon,\n    MultiPolygon,\n    GeometryCollection,\n} from 'geojson';\n\nexport function serialize(\n    featurecollection: GeoJsonFeatureCollection,\n    crsCode: number = 0,\n): Uint8Array {\n    const headerMeta = introspectHeaderMeta(featurecollection);\n    const header = buildHeader(headerMeta, crsCode);\n    const features: Uint8Array[] = featurecollection.features.map((f) =>\n        buildFeature(\n            f.geometry.type === 'GeometryCollection'\n                ? parseGC(f.geometry as GeometryCollection)\n                : parseGeometry(\n                      f.geometry as\n                          | Point\n                          | MultiPoint\n                          | LineString\n                          | MultiLineString\n                          | Polygon\n                          | MultiPolygon,\n                  ),\n            f.properties as IProperties,\n            headerMeta,\n        ),\n    );\n    const featuresLength = features\n        .map((f) => f.length)\n        .reduce((a, b) => a + b);\n    const uint8 = new Uint8Array(\n        magicbytes.length + header.length + featuresLength,\n    );\n    uint8.set(header, magicbytes.length);\n    let offset = magicbytes.length + header.length;\n    for (const feature of features) {\n        uint8.set(feature, offset);\n        offset += feature.length;\n    }\n    uint8.set(magicbytes);\n    return uint8;\n}\n\nexport function deserialize(\n    bytes: Uint8Array,\n    headerMetaFn?: HeaderMetaFn,\n): GeoJsonFeatureCollection {\n    const features = genericDeserialize(bytes, fromFeature, headerMetaFn);\n    return {\n        type: 'FeatureCollection',\n        features,\n    } as GeoJsonFeatureCollection;\n}\n\nexport function deserializeStream(\n    stream: ReadableStream,\n    headerMetaFn?: HeaderMetaFn,\n): AsyncGenerator<any, void, unknown> {\n    return genericDeserializeStream(stream, fromFeature, headerMetaFn);\n}\n\nexport function deserializeFiltered(\n    url: string,\n    rect: Rect,\n    headerMetaFn?: HeaderMetaFn,\n    nocache: boolean = false,\n): AsyncGenerator<any, void, unknown> {\n    return genericDeserializeFiltered(\n        url,\n        rect,\n        fromFeature,\n        headerMetaFn,\n        nocache,\n    );\n}\n\nfunction introspectHeaderMeta(\n    featurecollection: GeoJsonFeatureCollection,\n): HeaderMeta {\n    const feature = featurecollection.features[0];\n    const properties = feature.properties;\n\n    let columns: ColumnMeta[] | null = null;\n    if (properties)\n        columns = Object.keys(properties).map((k) => mapColumn(properties, k));\n\n    const geometryType = inferGeometryType(featurecollection.features);\n    const headerMeta: HeaderMeta = {\n        geometryType,\n        columns,\n        envelope: null,\n        featuresCount: featurecollection.features.length,\n        indexNodeSize: 0,\n        crs: null,\n        title: null,\n        description: null,\n        metadata: null,\n    };\n\n    return headerMeta;\n}\n","import {\n    deserialize as fcDeserialize,\n    deserializeStream as fcDeserializeStream,\n    deserializeFiltered as fcDeserializeFiltered,\n    serialize as fcSerialize,\n} from './geojson/featurecollection.js';\n\nimport { type FeatureCollection as GeoJsonFeatureCollection } from 'geojson';\n\nimport { type Rect } from './packedrtree.js';\nimport { type IGeoJsonFeature } from './geojson/feature.js';\nimport { type HeaderMetaFn } from './generic.js';\n\n/**\n * Serialize GeoJSON to FlatGeobuf\n * @param geojson GeoJSON object to serialize\n */\nexport function serialize(\n    geojson: GeoJsonFeatureCollection,\n    crsCode: number = 0,\n): Uint8Array {\n    const bytes = fcSerialize(geojson, crsCode);\n    return bytes;\n}\n\n/**\n * Deserialize FlatGeobuf into GeoJSON features\n * @param url Input string\n * @param rect Filter rectangle - NOT USED\n * @param headerMetaFn Callback that will receive header metadata when available\n */\nexport function deserialize(\n    url: string,\n    rect?: Rect,\n    headerMetaFn?: HeaderMetaFn,\n    nocache?: boolean,\n): AsyncGenerator<IGeoJsonFeature, any, unknown>;\n\n/**\n * Deserialize FlatGeobuf from a typed array into GeoJSON features\n * @note Does not support spatial filtering\n * @param typedArray Input byte array\n * @param rect Filter rectangle - NOT USED\n * @param headerMetaFn Callback that will receive header metadata when available\n */\nexport function deserialize(\n    typedArray: Uint8Array,\n    rect?: Rect,\n    headerMetaFn?: HeaderMetaFn,\n    nocache?: boolean,\n): GeoJsonFeatureCollection;\n\n/**\n * Deserialize FlatGeobuf from a stream into GeoJSON features\n * @note Does not support spatial filtering\n * @param stream stream\n * @param rect Filter rectangle\n * @param headerMetaFn Callback that will receive header metadata when available\n */\nexport function deserialize(\n    stream: ReadableStream,\n    rect?: Rect,\n    headerMetaFn?: HeaderMetaFn,\n    nocache?: boolean,\n): AsyncGenerator<IGeoJsonFeature>;\n\n/** Implementation */\nexport function deserialize(\n    input: Uint8Array | ReadableStream | string,\n    rect?: Rect,\n    headerMetaFn?: HeaderMetaFn,\n    nocache: boolean = false,\n): GeoJsonFeatureCollection | AsyncGenerator<IGeoJsonFeature> {\n    if (input instanceof Uint8Array) return fcDeserialize(input, headerMetaFn);\n    else if (input instanceof ReadableStream)\n        return fcDeserializeStream(input, headerMetaFn);\n    else return fcDeserializeFiltered(input, rect!, headerMetaFn, nocache);\n}\n","// automatically generated by the FlatBuffers compiler, do not modify\n\n/* eslint-disable @typescript-eslint/no-unused-vars, @typescript-eslint/no-explicit-any, @typescript-eslint/no-non-null-assertion */\n\nexport enum GeometryType {\n  Unknown = 0,\n  Point = 1,\n  LineString = 2,\n  Polygon = 3,\n  MultiPoint = 4,\n  MultiLineString = 5,\n  MultiPolygon = 6,\n  GeometryCollection = 7,\n  CircularString = 8,\n  CompoundCurve = 9,\n  CurvePolygon = 10,\n  MultiCurve = 11,\n  MultiSurface = 12,\n  Curve = 13,\n  Surface = 14,\n  PolyhedralSurface = 15,\n  TIN = 16,\n  Triangle = 17\n}\n","export const SIZEOF_SHORT = 2;\nexport const SIZEOF_INT = 4;\nexport const FILE_IDENTIFIER_LENGTH = 4;\nexport const SIZE_PREFIX_LENGTH = 4;\n","export var Encoding;\n(function (Encoding) {\n    Encoding[Encoding[\"UTF8_BYTES\"] = 1] = \"UTF8_BYTES\";\n    Encoding[Encoding[\"UTF16_STRING\"] = 2] = \"UTF16_STRING\";\n})(Encoding || (Encoding = {}));\n","export const int32 = new Int32Array(2);\nexport const float32 = new Float32Array(int32.buffer);\nexport const float64 = new Float64Array(int32.buffer);\nexport const isLittleEndian = new Uint16Array(new Uint8Array([1, 0]).buffer)[0] === 1;\n","import { FILE_IDENTIFIER_LENGTH, SIZEOF_INT } from \"./constants.js\";\nimport { int32, isLittleEndian, float32, float64 } from \"./utils.js\";\nimport { Encoding } from \"./encoding.js\";\nexport class ByteBuffer {\n    /**\n     * Create a new ByteBuffer with a given array of bytes (`Uint8Array`)\n     */\n    constructor(bytes_) {\n        this.bytes_ = bytes_;\n        this.position_ = 0;\n        this.text_decoder_ = new TextDecoder();\n    }\n    /**\n     * Create and allocate a new ByteBuffer with a given size.\n     */\n    static allocate(byte_size) {\n        return new ByteBuffer(new Uint8Array(byte_size));\n    }\n    clear() {\n        this.position_ = 0;\n    }\n    /**\n     * Get the underlying `Uint8Array`.\n     */\n    bytes() {\n        return this.bytes_;\n    }\n    /**\n     * Get the buffer's position.\n     */\n    position() {\n        return this.position_;\n    }\n    /**\n     * Set the buffer's position.\n     */\n    setPosition(position) {\n        this.position_ = position;\n    }\n    /**\n     * Get the buffer's capacity.\n     */\n    capacity() {\n        return this.bytes_.length;\n    }\n    readInt8(offset) {\n        return this.readUint8(offset) << 24 >> 24;\n    }\n    readUint8(offset) {\n        return this.bytes_[offset];\n    }\n    readInt16(offset) {\n        return this.readUint16(offset) << 16 >> 16;\n    }\n    readUint16(offset) {\n        return this.bytes_[offset] | this.bytes_[offset + 1] << 8;\n    }\n    readInt32(offset) {\n        return this.bytes_[offset] | this.bytes_[offset + 1] << 8 | this.bytes_[offset + 2] << 16 | this.bytes_[offset + 3] << 24;\n    }\n    readUint32(offset) {\n        return this.readInt32(offset) >>> 0;\n    }\n    readInt64(offset) {\n        return BigInt.asIntN(64, BigInt(this.readUint32(offset)) + (BigInt(this.readUint32(offset + 4)) << BigInt(32)));\n    }\n    readUint64(offset) {\n        return BigInt.asUintN(64, BigInt(this.readUint32(offset)) + (BigInt(this.readUint32(offset + 4)) << BigInt(32)));\n    }\n    readFloat32(offset) {\n        int32[0] = this.readInt32(offset);\n        return float32[0];\n    }\n    readFloat64(offset) {\n        int32[isLittleEndian ? 0 : 1] = this.readInt32(offset);\n        int32[isLittleEndian ? 1 : 0] = this.readInt32(offset + 4);\n        return float64[0];\n    }\n    writeInt8(offset, value) {\n        this.bytes_[offset] = value;\n    }\n    writeUint8(offset, value) {\n        this.bytes_[offset] = value;\n    }\n    writeInt16(offset, value) {\n        this.bytes_[offset] = value;\n        this.bytes_[offset + 1] = value >> 8;\n    }\n    writeUint16(offset, value) {\n        this.bytes_[offset] = value;\n        this.bytes_[offset + 1] = value >> 8;\n    }\n    writeInt32(offset, value) {\n        this.bytes_[offset] = value;\n        this.bytes_[offset + 1] = value >> 8;\n        this.bytes_[offset + 2] = value >> 16;\n        this.bytes_[offset + 3] = value >> 24;\n    }\n    writeUint32(offset, value) {\n        this.bytes_[offset] = value;\n        this.bytes_[offset + 1] = value >> 8;\n        this.bytes_[offset + 2] = value >> 16;\n        this.bytes_[offset + 3] = value >> 24;\n    }\n    writeInt64(offset, value) {\n        this.writeInt32(offset, Number(BigInt.asIntN(32, value)));\n        this.writeInt32(offset + 4, Number(BigInt.asIntN(32, value >> BigInt(32))));\n    }\n    writeUint64(offset, value) {\n        this.writeUint32(offset, Number(BigInt.asUintN(32, value)));\n        this.writeUint32(offset + 4, Number(BigInt.asUintN(32, value >> BigInt(32))));\n    }\n    writeFloat32(offset, value) {\n        float32[0] = value;\n        this.writeInt32(offset, int32[0]);\n    }\n    writeFloat64(offset, value) {\n        float64[0] = value;\n        this.writeInt32(offset, int32[isLittleEndian ? 0 : 1]);\n        this.writeInt32(offset + 4, int32[isLittleEndian ? 1 : 0]);\n    }\n    /**\n     * Return the file identifier.   Behavior is undefined for FlatBuffers whose\n     * schema does not include a file_identifier (likely points at padding or the\n     * start of a the root vtable).\n     */\n    getBufferIdentifier() {\n        if (this.bytes_.length < this.position_ + SIZEOF_INT +\n            FILE_IDENTIFIER_LENGTH) {\n            throw new Error('FlatBuffers: ByteBuffer is too short to contain an identifier.');\n        }\n        let result = \"\";\n        for (let i = 0; i < FILE_IDENTIFIER_LENGTH; i++) {\n            result += String.fromCharCode(this.readInt8(this.position_ + SIZEOF_INT + i));\n        }\n        return result;\n    }\n    /**\n     * Look up a field in the vtable, return an offset into the object, or 0 if the\n     * field is not present.\n     */\n    __offset(bb_pos, vtable_offset) {\n        const vtable = bb_pos - this.readInt32(bb_pos);\n        return vtable_offset < this.readInt16(vtable) ? this.readInt16(vtable + vtable_offset) : 0;\n    }\n    /**\n     * Initialize any Table-derived type to point to the union at the given offset.\n     */\n    __union(t, offset) {\n        t.bb_pos = offset + this.readInt32(offset);\n        t.bb = this;\n        return t;\n    }\n    /**\n     * Create a JavaScript string from UTF-8 data stored inside the FlatBuffer.\n     * This allocates a new string and converts to wide chars upon each access.\n     *\n     * To avoid the conversion to string, pass Encoding.UTF8_BYTES as the\n     * \"optionalEncoding\" argument. This is useful for avoiding conversion when\n     * the data will just be packaged back up in another FlatBuffer later on.\n     *\n     * @param offset\n     * @param opt_encoding Defaults to UTF16_STRING\n     */\n    __string(offset, opt_encoding) {\n        offset += this.readInt32(offset);\n        const length = this.readInt32(offset);\n        offset += SIZEOF_INT;\n        const utf8bytes = this.bytes_.subarray(offset, offset + length);\n        if (opt_encoding === Encoding.UTF8_BYTES)\n            return utf8bytes;\n        else\n            return this.text_decoder_.decode(utf8bytes);\n    }\n    /**\n     * Handle unions that can contain string as its member, if a Table-derived type then initialize it,\n     * if a string then return a new one\n     *\n     * WARNING: strings are immutable in JS so we can't change the string that the user gave us, this\n     * makes the behaviour of __union_with_string different compared to __union\n     */\n    __union_with_string(o, offset) {\n        if (typeof o === 'string') {\n            return this.__string(offset);\n        }\n        return this.__union(o, offset);\n    }\n    /**\n     * Retrieve the relative offset stored at \"offset\"\n     */\n    __indirect(offset) {\n        return offset + this.readInt32(offset);\n    }\n    /**\n     * Get the start of data of a vector whose offset is stored at \"offset\" in this object.\n     */\n    __vector(offset) {\n        return offset + this.readInt32(offset) + SIZEOF_INT; // data starts after the length\n    }\n    /**\n     * Get the length of a vector whose offset is stored at \"offset\" in this object.\n     */\n    __vector_len(offset) {\n        return this.readInt32(offset + this.readInt32(offset));\n    }\n    __has_identifier(ident) {\n        if (ident.length != FILE_IDENTIFIER_LENGTH) {\n            throw new Error('FlatBuffers: file identifier must be length ' +\n                FILE_IDENTIFIER_LENGTH);\n        }\n        for (let i = 0; i < FILE_IDENTIFIER_LENGTH; i++) {\n            if (ident.charCodeAt(i) != this.readInt8(this.position() + SIZEOF_INT + i)) {\n                return false;\n            }\n        }\n        return true;\n    }\n    /**\n     * A helper function for generating list for obj api\n     */\n    createScalarList(listAccessor, listLength) {\n        const ret = [];\n        for (let i = 0; i < listLength; ++i) {\n            const val = listAccessor(i);\n            if (val !== null) {\n                ret.push(val);\n            }\n        }\n        return ret;\n    }\n    /**\n     * A helper function for generating list for obj api\n     * @param listAccessor function that accepts an index and return data at that index\n     * @param listLength listLength\n     * @param res result list\n     */\n    createObjList(listAccessor, listLength) {\n        const ret = [];\n        for (let i = 0; i < listLength; ++i) {\n            const val = listAccessor(i);\n            if (val !== null) {\n                ret.push(val.unpack());\n            }\n        }\n        return ret;\n    }\n}\n","// automatically generated by the FlatBuffers compiler, do not modify\n\n/* eslint-disable @typescript-eslint/no-unused-vars, @typescript-eslint/no-explicit-any, @typescript-eslint/no-non-null-assertion */\n\nexport enum ColumnType {\n  Byte = 0,\n  UByte = 1,\n  Bool = 2,\n  Short = 3,\n  UShort = 4,\n  Int = 5,\n  UInt = 6,\n  Long = 7,\n  ULong = 8,\n  Float = 9,\n  Double = 10,\n  String = 11,\n  Json = 12,\n  DateTime = 13,\n  Binary = 14\n}\n","import { ByteBuffer } from \"./byte-buffer.js\";\nimport { SIZEOF_SHORT, SIZE_PREFIX_LENGTH, SIZEOF_INT, FILE_IDENTIFIER_LENGTH } from \"./constants.js\";\nexport class Builder {\n    /**\n     * Create a FlatBufferBuilder.\n     */\n    constructor(opt_initial_size) {\n        /** Minimum alignment encountered so far. */\n        this.minalign = 1;\n        /** The vtable for the current table. */\n        this.vtable = null;\n        /** The amount of fields we're actually using. */\n        this.vtable_in_use = 0;\n        /** Whether we are currently serializing a table. */\n        this.isNested = false;\n        /** Starting offset of the current struct/table. */\n        this.object_start = 0;\n        /** List of offsets of all vtables. */\n        this.vtables = [];\n        /** For the current vector being built. */\n        this.vector_num_elems = 0;\n        /** False omits default values from the serialized data */\n        this.force_defaults = false;\n        this.string_maps = null;\n        this.text_encoder = new TextEncoder();\n        let initial_size;\n        if (!opt_initial_size) {\n            initial_size = 1024;\n        }\n        else {\n            initial_size = opt_initial_size;\n        }\n        /**\n         * @type {ByteBuffer}\n         * @private\n         */\n        this.bb = ByteBuffer.allocate(initial_size);\n        this.space = initial_size;\n    }\n    clear() {\n        this.bb.clear();\n        this.space = this.bb.capacity();\n        this.minalign = 1;\n        this.vtable = null;\n        this.vtable_in_use = 0;\n        this.isNested = false;\n        this.object_start = 0;\n        this.vtables = [];\n        this.vector_num_elems = 0;\n        this.force_defaults = false;\n        this.string_maps = null;\n    }\n    /**\n     * In order to save space, fields that are set to their default value\n     * don't get serialized into the buffer. Forcing defaults provides a\n     * way to manually disable this optimization.\n     *\n     * @param forceDefaults true always serializes default values\n     */\n    forceDefaults(forceDefaults) {\n        this.force_defaults = forceDefaults;\n    }\n    /**\n     * Get the ByteBuffer representing the FlatBuffer. Only call this after you've\n     * called finish(). The actual data starts at the ByteBuffer's current position,\n     * not necessarily at 0.\n     */\n    dataBuffer() {\n        return this.bb;\n    }\n    /**\n     * Get the bytes representing the FlatBuffer. Only call this after you've\n     * called finish().\n     */\n    asUint8Array() {\n        return this.bb.bytes().subarray(this.bb.position(), this.bb.position() + this.offset());\n    }\n    /**\n     * Prepare to write an element of `size` after `additional_bytes` have been\n     * written, e.g. if you write a string, you need to align such the int length\n     * field is aligned to 4 bytes, and the string data follows it directly. If all\n     * you need to do is alignment, `additional_bytes` will be 0.\n     *\n     * @param size This is the of the new element to write\n     * @param additional_bytes The padding size\n     */\n    prep(size, additional_bytes) {\n        // Track the biggest thing we've ever aligned to.\n        if (size > this.minalign) {\n            this.minalign = size;\n        }\n        // Find the amount of alignment needed such that `size` is properly\n        // aligned after `additional_bytes`\n        const align_size = ((~(this.bb.capacity() - this.space + additional_bytes)) + 1) & (size - 1);\n        // Reallocate the buffer if needed.\n        while (this.space < align_size + size + additional_bytes) {\n            const old_buf_size = this.bb.capacity();\n            this.bb = Builder.growByteBuffer(this.bb);\n            this.space += this.bb.capacity() - old_buf_size;\n        }\n        this.pad(align_size);\n    }\n    pad(byte_size) {\n        for (let i = 0; i < byte_size; i++) {\n            this.bb.writeInt8(--this.space, 0);\n        }\n    }\n    writeInt8(value) {\n        this.bb.writeInt8(this.space -= 1, value);\n    }\n    writeInt16(value) {\n        this.bb.writeInt16(this.space -= 2, value);\n    }\n    writeInt32(value) {\n        this.bb.writeInt32(this.space -= 4, value);\n    }\n    writeInt64(value) {\n        this.bb.writeInt64(this.space -= 8, value);\n    }\n    writeFloat32(value) {\n        this.bb.writeFloat32(this.space -= 4, value);\n    }\n    writeFloat64(value) {\n        this.bb.writeFloat64(this.space -= 8, value);\n    }\n    /**\n     * Add an `int8` to the buffer, properly aligned, and grows the buffer (if necessary).\n     * @param value The `int8` to add the buffer.\n     */\n    addInt8(value) {\n        this.prep(1, 0);\n        this.writeInt8(value);\n    }\n    /**\n     * Add an `int16` to the buffer, properly aligned, and grows the buffer (if necessary).\n     * @param value The `int16` to add the buffer.\n     */\n    addInt16(value) {\n        this.prep(2, 0);\n        this.writeInt16(value);\n    }\n    /**\n     * Add an `int32` to the buffer, properly aligned, and grows the buffer (if necessary).\n     * @param value The `int32` to add the buffer.\n     */\n    addInt32(value) {\n        this.prep(4, 0);\n        this.writeInt32(value);\n    }\n    /**\n     * Add an `int64` to the buffer, properly aligned, and grows the buffer (if necessary).\n     * @param value The `int64` to add the buffer.\n     */\n    addInt64(value) {\n        this.prep(8, 0);\n        this.writeInt64(value);\n    }\n    /**\n     * Add a `float32` to the buffer, properly aligned, and grows the buffer (if necessary).\n     * @param value The `float32` to add the buffer.\n     */\n    addFloat32(value) {\n        this.prep(4, 0);\n        this.writeFloat32(value);\n    }\n    /**\n     * Add a `float64` to the buffer, properly aligned, and grows the buffer (if necessary).\n     * @param value The `float64` to add the buffer.\n     */\n    addFloat64(value) {\n        this.prep(8, 0);\n        this.writeFloat64(value);\n    }\n    addFieldInt8(voffset, value, defaultValue) {\n        if (this.force_defaults || value != defaultValue) {\n            this.addInt8(value);\n            this.slot(voffset);\n        }\n    }\n    addFieldInt16(voffset, value, defaultValue) {\n        if (this.force_defaults || value != defaultValue) {\n            this.addInt16(value);\n            this.slot(voffset);\n        }\n    }\n    addFieldInt32(voffset, value, defaultValue) {\n        if (this.force_defaults || value != defaultValue) {\n            this.addInt32(value);\n            this.slot(voffset);\n        }\n    }\n    addFieldInt64(voffset, value, defaultValue) {\n        if (this.force_defaults || value !== defaultValue) {\n            this.addInt64(value);\n            this.slot(voffset);\n        }\n    }\n    addFieldFloat32(voffset, value, defaultValue) {\n        if (this.force_defaults || value != defaultValue) {\n            this.addFloat32(value);\n            this.slot(voffset);\n        }\n    }\n    addFieldFloat64(voffset, value, defaultValue) {\n        if (this.force_defaults || value != defaultValue) {\n            this.addFloat64(value);\n            this.slot(voffset);\n        }\n    }\n    addFieldOffset(voffset, value, defaultValue) {\n        if (this.force_defaults || value != defaultValue) {\n            this.addOffset(value);\n            this.slot(voffset);\n        }\n    }\n    /**\n     * Structs are stored inline, so nothing additional is being added. `d` is always 0.\n     */\n    addFieldStruct(voffset, value, defaultValue) {\n        if (value != defaultValue) {\n            this.nested(value);\n            this.slot(voffset);\n        }\n    }\n    /**\n     * Structures are always stored inline, they need to be created right\n     * where they're used.  You'll get this assertion failure if you\n     * created it elsewhere.\n     */\n    nested(obj) {\n        if (obj != this.offset()) {\n            throw new TypeError('FlatBuffers: struct must be serialized inline.');\n        }\n    }\n    /**\n     * Should not be creating any other object, string or vector\n     * while an object is being constructed\n     */\n    notNested() {\n        if (this.isNested) {\n            throw new TypeError('FlatBuffers: object serialization must not be nested.');\n        }\n    }\n    /**\n     * Set the current vtable at `voffset` to the current location in the buffer.\n     */\n    slot(voffset) {\n        if (this.vtable !== null)\n            this.vtable[voffset] = this.offset();\n    }\n    /**\n     * @returns Offset relative to the end of the buffer.\n     */\n    offset() {\n        return this.bb.capacity() - this.space;\n    }\n    /**\n     * Doubles the size of the backing ByteBuffer and copies the old data towards\n     * the end of the new buffer (since we build the buffer backwards).\n     *\n     * @param bb The current buffer with the existing data\n     * @returns A new byte buffer with the old data copied\n     * to it. The data is located at the end of the buffer.\n     *\n     * uint8Array.set() formally takes {Array<number>|ArrayBufferView}, so to pass\n     * it a uint8Array we need to suppress the type check:\n     * @suppress {checkTypes}\n     */\n    static growByteBuffer(bb) {\n        const old_buf_size = bb.capacity();\n        // Ensure we don't grow beyond what fits in an int.\n        if (old_buf_size & 0xC0000000) {\n            throw new Error('FlatBuffers: cannot grow buffer beyond 2 gigabytes.');\n        }\n        const new_buf_size = old_buf_size << 1;\n        const nbb = ByteBuffer.allocate(new_buf_size);\n        nbb.setPosition(new_buf_size - old_buf_size);\n        nbb.bytes().set(bb.bytes(), new_buf_size - old_buf_size);\n        return nbb;\n    }\n    /**\n     * Adds on offset, relative to where it will be written.\n     *\n     * @param offset The offset to add.\n     */\n    addOffset(offset) {\n        this.prep(SIZEOF_INT, 0); // Ensure alignment is already done.\n        this.writeInt32(this.offset() - offset + SIZEOF_INT);\n    }\n    /**\n     * Start encoding a new object in the buffer.  Users will not usually need to\n     * call this directly. The FlatBuffers compiler will generate helper methods\n     * that call this method internally.\n     */\n    startObject(numfields) {\n        this.notNested();\n        if (this.vtable == null) {\n            this.vtable = [];\n        }\n        this.vtable_in_use = numfields;\n        for (let i = 0; i < numfields; i++) {\n            this.vtable[i] = 0; // This will push additional elements as needed\n        }\n        this.isNested = true;\n        this.object_start = this.offset();\n    }\n    /**\n     * Finish off writing the object that is under construction.\n     *\n     * @returns The offset to the object inside `dataBuffer`\n     */\n    endObject() {\n        if (this.vtable == null || !this.isNested) {\n            throw new Error('FlatBuffers: endObject called without startObject');\n        }\n        this.addInt32(0);\n        const vtableloc = this.offset();\n        // Trim trailing zeroes.\n        let i = this.vtable_in_use - 1;\n        // eslint-disable-next-line no-empty\n        for (; i >= 0 && this.vtable[i] == 0; i--) { }\n        const trimmed_size = i + 1;\n        // Write out the current vtable.\n        for (; i >= 0; i--) {\n            // Offset relative to the start of the table.\n            this.addInt16(this.vtable[i] != 0 ? vtableloc - this.vtable[i] : 0);\n        }\n        const standard_fields = 2; // The fields below:\n        this.addInt16(vtableloc - this.object_start);\n        const len = (trimmed_size + standard_fields) * SIZEOF_SHORT;\n        this.addInt16(len);\n        // Search for an existing vtable that matches the current one.\n        let existing_vtable = 0;\n        const vt1 = this.space;\n        outer_loop: for (i = 0; i < this.vtables.length; i++) {\n            const vt2 = this.bb.capacity() - this.vtables[i];\n            if (len == this.bb.readInt16(vt2)) {\n                for (let j = SIZEOF_SHORT; j < len; j += SIZEOF_SHORT) {\n                    if (this.bb.readInt16(vt1 + j) != this.bb.readInt16(vt2 + j)) {\n                        continue outer_loop;\n                    }\n                }\n                existing_vtable = this.vtables[i];\n                break;\n            }\n        }\n        if (existing_vtable) {\n            // Found a match:\n            // Remove the current vtable.\n            this.space = this.bb.capacity() - vtableloc;\n            // Point table to existing vtable.\n            this.bb.writeInt32(this.space, existing_vtable - vtableloc);\n        }\n        else {\n            // No match:\n            // Add the location of the current vtable to the list of vtables.\n            this.vtables.push(this.offset());\n            // Point table to current vtable.\n            this.bb.writeInt32(this.bb.capacity() - vtableloc, this.offset() - vtableloc);\n        }\n        this.isNested = false;\n        return vtableloc;\n    }\n    /**\n     * Finalize a buffer, poiting to the given `root_table`.\n     */\n    finish(root_table, opt_file_identifier, opt_size_prefix) {\n        const size_prefix = opt_size_prefix ? SIZE_PREFIX_LENGTH : 0;\n        if (opt_file_identifier) {\n            const file_identifier = opt_file_identifier;\n            this.prep(this.minalign, SIZEOF_INT +\n                FILE_IDENTIFIER_LENGTH + size_prefix);\n            if (file_identifier.length != FILE_IDENTIFIER_LENGTH) {\n                throw new TypeError('FlatBuffers: file identifier must be length ' +\n                    FILE_IDENTIFIER_LENGTH);\n            }\n            for (let i = FILE_IDENTIFIER_LENGTH - 1; i >= 0; i--) {\n                this.writeInt8(file_identifier.charCodeAt(i));\n            }\n        }\n        this.prep(this.minalign, SIZEOF_INT + size_prefix);\n        this.addOffset(root_table);\n        if (size_prefix) {\n            this.addInt32(this.bb.capacity() - this.space);\n        }\n        this.bb.setPosition(this.space);\n    }\n    /**\n     * Finalize a size prefixed buffer, pointing to the given `root_table`.\n     */\n    finishSizePrefixed(root_table, opt_file_identifier) {\n        this.finish(root_table, opt_file_identifier, true);\n    }\n    /**\n     * This checks a required field has been set in a given table that has\n     * just been constructed.\n     */\n    requiredField(table, field) {\n        const table_start = this.bb.capacity() - table;\n        const vtable_start = table_start - this.bb.readInt32(table_start);\n        const ok = field < this.bb.readInt16(vtable_start) &&\n            this.bb.readInt16(vtable_start + field) != 0;\n        // If this fails, the caller will show what field needs to be set.\n        if (!ok) {\n            throw new TypeError('FlatBuffers: field ' + field + ' must be set');\n        }\n    }\n    /**\n     * Start a new array/vector of objects.  Users usually will not call\n     * this directly. The FlatBuffers compiler will create a start/end\n     * method for vector types in generated code.\n     *\n     * @param elem_size The size of each element in the array\n     * @param num_elems The number of elements in the array\n     * @param alignment The alignment of the array\n     */\n    startVector(elem_size, num_elems, alignment) {\n        this.notNested();\n        this.vector_num_elems = num_elems;\n        this.prep(SIZEOF_INT, elem_size * num_elems);\n        this.prep(alignment, elem_size * num_elems); // Just in case alignment > int.\n    }\n    /**\n     * Finish off the creation of an array and all its elements. The array must be\n     * created with `startVector`.\n     *\n     * @returns The offset at which the newly created array\n     * starts.\n     */\n    endVector() {\n        this.writeInt32(this.vector_num_elems);\n        return this.offset();\n    }\n    /**\n     * Encode the string `s` in the buffer using UTF-8. If the string passed has\n     * already been seen, we return the offset of the already written string\n     *\n     * @param s The string to encode\n     * @return The offset in the buffer where the encoded string starts\n     */\n    createSharedString(s) {\n        if (!s) {\n            return 0;\n        }\n        if (!this.string_maps) {\n            this.string_maps = new Map();\n        }\n        if (this.string_maps.has(s)) {\n            return this.string_maps.get(s);\n        }\n        const offset = this.createString(s);\n        this.string_maps.set(s, offset);\n        return offset;\n    }\n    /**\n     * Encode the string `s` in the buffer using UTF-8. If a Uint8Array is passed\n     * instead of a string, it is assumed to contain valid UTF-8 encoded data.\n     *\n     * @param s The string to encode\n     * @return The offset in the buffer where the encoded string starts\n     */\n    createString(s) {\n        if (s === null || s === undefined) {\n            return 0;\n        }\n        let utf8;\n        if (s instanceof Uint8Array) {\n            utf8 = s;\n        }\n        else {\n            utf8 = this.text_encoder.encode(s);\n        }\n        this.addInt8(0);\n        this.startVector(1, utf8.length, 1);\n        this.bb.setPosition(this.space -= utf8.length);\n        this.bb.bytes().set(utf8, this.space);\n        return this.endVector();\n    }\n    /**\n     * Create a byte vector.\n     *\n     * @param v The bytes to add\n     * @returns The offset in the buffer where the byte vector starts\n     */\n    createByteVector(v) {\n        if (v === null || v === undefined) {\n            return 0;\n        }\n        this.startVector(1, v.length, 1);\n        this.bb.setPosition(this.space -= v.length);\n        this.bb.bytes().set(v, this.space);\n        return this.endVector();\n    }\n    /**\n     * A helper function to pack an object\n     *\n     * @returns offset of obj\n     */\n    createObjectOffset(obj) {\n        if (obj === null) {\n            return 0;\n        }\n        if (typeof obj === 'string') {\n            return this.createString(obj);\n        }\n        else {\n            return obj.pack(this);\n        }\n    }\n    /**\n     * A helper function to pack a list of object\n     *\n     * @returns list of offsets of each non null object\n     */\n    createObjectOffsetList(list) {\n        const ret = [];\n        for (let i = 0; i < list.length; ++i) {\n            const val = list[i];\n            if (val !== null) {\n                ret.push(this.createObjectOffset(val));\n            }\n            else {\n                throw new TypeError('FlatBuffers: Argument for createObjectOffsetList cannot contain null.');\n            }\n        }\n        return ret;\n    }\n    createStructOffsetList(list, startFunc) {\n        startFunc(this, list.length);\n        this.createObjectOffsetList(list.slice().reverse());\n        return this.endVector();\n    }\n}\n","// automatically generated by the FlatBuffers compiler, do not modify\n\n/* eslint-disable @typescript-eslint/no-unused-vars, @typescript-eslint/no-explicit-any, @typescript-eslint/no-non-null-assertion */\n\nimport * as flatbuffers from 'flatbuffers';\n\nimport { GeometryType } from '../flat-geobuf/geometry-type.js';\n\n\nexport class Geometry {\n  bb: flatbuffers.ByteBuffer|null = null;\n  bb_pos = 0;\n  __init(i:number, bb:flatbuffers.ByteBuffer):Geometry {\n  this.bb_pos = i;\n  this.bb = bb;\n  return this;\n}\n\nstatic getRootAsGeometry(bb:flatbuffers.ByteBuffer, obj?:Geometry):Geometry {\n  return (obj || new Geometry()).__init(bb.readInt32(bb.position()) + bb.position(), bb);\n}\n\nstatic getSizePrefixedRootAsGeometry(bb:flatbuffers.ByteBuffer, obj?:Geometry):Geometry {\n  bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);\n  return (obj || new Geometry()).__init(bb.readInt32(bb.position()) + bb.position(), bb);\n}\n\nends(index: number):number|null {\n  const offset = this.bb!.__offset(this.bb_pos, 4);\n  return offset ? this.bb!.readUint32(this.bb!.__vector(this.bb_pos + offset) + index * 4) : 0;\n}\n\nendsLength():number {\n  const offset = this.bb!.__offset(this.bb_pos, 4);\n  return offset ? this.bb!.__vector_len(this.bb_pos + offset) : 0;\n}\n\nendsArray():Uint32Array|null {\n  const offset = this.bb!.__offset(this.bb_pos, 4);\n  return offset ? new Uint32Array(this.bb!.bytes().buffer, this.bb!.bytes().byteOffset + this.bb!.__vector(this.bb_pos + offset), this.bb!.__vector_len(this.bb_pos + offset)) : null;\n}\n\nxy(index: number):number|null {\n  const offset = this.bb!.__offset(this.bb_pos, 6);\n  return offset ? this.bb!.readFloat64(this.bb!.__vector(this.bb_pos + offset) + index * 8) : 0;\n}\n\nxyLength():number {\n  const offset = this.bb!.__offset(this.bb_pos, 6);\n  return offset ? this.bb!.__vector_len(this.bb_pos + offset) : 0;\n}\n\nxyArray():Float64Array|null {\n  const offset = this.bb!.__offset(this.bb_pos, 6);\n  return offset ? new Float64Array(this.bb!.bytes().buffer, this.bb!.bytes().byteOffset + this.bb!.__vector(this.bb_pos + offset), this.bb!.__vector_len(this.bb_pos + offset)) : null;\n}\n\nz(index: number):number|null {\n  const offset = this.bb!.__offset(this.bb_pos, 8);\n  return offset ? this.bb!.readFloat64(this.bb!.__vector(this.bb_pos + offset) + index * 8) : 0;\n}\n\nzLength():number {\n  const offset = this.bb!.__offset(this.bb_pos, 8);\n  return offset ? this.bb!.__vector_len(this.bb_pos + offset) : 0;\n}\n\nzArray():Float64Array|null {\n  const offset = this.bb!.__offset(this.bb_pos, 8);\n  return offset ? new Float64Array(this.bb!.bytes().buffer, this.bb!.bytes().byteOffset + this.bb!.__vector(this.bb_pos + offset), this.bb!.__vector_len(this.bb_pos + offset)) : null;\n}\n\nm(index: number):number|null {\n  const offset = this.bb!.__offset(this.bb_pos, 10);\n  return offset ? this.bb!.readFloat64(this.bb!.__vector(this.bb_pos + offset) + index * 8) : 0;\n}\n\nmLength():number {\n  const offset = this.bb!.__offset(this.bb_pos, 10);\n  return offset ? this.bb!.__vector_len(this.bb_pos + offset) : 0;\n}\n\nmArray():Float64Array|null {\n  const offset = this.bb!.__offset(this.bb_pos, 10);\n  return offset ? new Float64Array(this.bb!.bytes().buffer, this.bb!.bytes().byteOffset + this.bb!.__vector(this.bb_pos + offset), this.bb!.__vector_len(this.bb_pos + offset)) : null;\n}\n\nt(index: number):number|null {\n  const offset = this.bb!.__offset(this.bb_pos, 12);\n  return offset ? this.bb!.readFloat64(this.bb!.__vector(this.bb_pos + offset) + index * 8) : 0;\n}\n\ntLength():number {\n  const offset = this.bb!.__offset(this.bb_pos, 12);\n  return offset ? this.bb!.__vector_len(this.bb_pos + offset) : 0;\n}\n\ntArray():Float64Array|null {\n  const offset = this.bb!.__offset(this.bb_pos, 12);\n  return offset ? new Float64Array(this.bb!.bytes().buffer, this.bb!.bytes().byteOffset + this.bb!.__vector(this.bb_pos + offset), this.bb!.__vector_len(this.bb_pos + offset)) : null;\n}\n\ntm(index: number):bigint|null {\n  const offset = this.bb!.__offset(this.bb_pos, 14);\n  return offset ? this.bb!.readUint64(this.bb!.__vector(this.bb_pos + offset) + index * 8) : BigInt(0);\n}\n\ntmLength():number {\n  const offset = this.bb!.__offset(this.bb_pos, 14);\n  return offset ? this.bb!.__vector_len(this.bb_pos + offset) : 0;\n}\n\ntype():GeometryType {\n  const offset = this.bb!.__offset(this.bb_pos, 16);\n  return offset ? this.bb!.readUint8(this.bb_pos + offset) : GeometryType.Unknown;\n}\n\nparts(index: number, obj?:Geometry):Geometry|null {\n  const offset = this.bb!.__offset(this.bb_pos, 18);\n  return offset ? (obj || new Geometry()).__init(this.bb!.__indirect(this.bb!.__vector(this.bb_pos + offset) + index * 4), this.bb!) : null;\n}\n\npartsLength():number {\n  const offset = this.bb!.__offset(this.bb_pos, 18);\n  return offset ? this.bb!.__vector_len(this.bb_pos + offset) : 0;\n}\n\nstatic startGeometry(builder:flatbuffers.Builder) {\n  builder.startObject(8);\n}\n\nstatic addEnds(builder:flatbuffers.Builder, endsOffset:flatbuffers.Offset) {\n  builder.addFieldOffset(0, endsOffset, 0);\n}\n\nstatic createEndsVector(builder:flatbuffers.Builder, data:number[]|Uint32Array):flatbuffers.Offset;\n/**\n * @deprecated This Uint8Array overload will be removed in the future.\n */\nstatic createEndsVector(builder:flatbuffers.Builder, data:number[]|Uint8Array):flatbuffers.Offset;\nstatic createEndsVector(builder:flatbuffers.Builder, data:number[]|Uint32Array|Uint8Array):flatbuffers.Offset {\n  builder.startVector(4, data.length, 4);\n  for (let i = data.length - 1; i >= 0; i--) {\n    builder.addInt32(data[i]!);\n  }\n  return builder.endVector();\n}\n\nstatic startEndsVector(builder:flatbuffers.Builder, numElems:number) {\n  builder.startVector(4, numElems, 4);\n}\n\nstatic addXy(builder:flatbuffers.Builder, xyOffset:flatbuffers.Offset) {\n  builder.addFieldOffset(1, xyOffset, 0);\n}\n\nstatic createXyVector(builder:flatbuffers.Builder, data:number[]|Float64Array):flatbuffers.Offset;\n/**\n * @deprecated This Uint8Array overload will be removed in the future.\n */\nstatic createXyVector(builder:flatbuffers.Builder, data:number[]|Uint8Array):flatbuffers.Offset;\nstatic createXyVector(builder:flatbuffers.Builder, data:number[]|Float64Array|Uint8Array):flatbuffers.Offset {\n  builder.startVector(8, data.length, 8);\n  for (let i = data.length - 1; i >= 0; i--) {\n    builder.addFloat64(data[i]!);\n  }\n  return builder.endVector();\n}\n\nstatic startXyVector(builder:flatbuffers.Builder, numElems:number) {\n  builder.startVector(8, numElems, 8);\n}\n\nstatic addZ(builder:flatbuffers.Builder, zOffset:flatbuffers.Offset) {\n  builder.addFieldOffset(2, zOffset, 0);\n}\n\nstatic createZVector(builder:flatbuffers.Builder, data:number[]|Float64Array):flatbuffers.Offset;\n/**\n * @deprecated This Uint8Array overload will be removed in the future.\n */\nstatic createZVector(builder:flatbuffers.Builder, data:number[]|Uint8Array):flatbuffers.Offset;\nstatic createZVector(builder:flatbuffers.Builder, data:number[]|Float64Array|Uint8Array):flatbuffers.Offset {\n  builder.startVector(8, data.length, 8);\n  for (let i = data.length - 1; i >= 0; i--) {\n    builder.addFloat64(data[i]!);\n  }\n  return builder.endVector();\n}\n\nstatic startZVector(builder:flatbuffers.Builder, numElems:number) {\n  builder.startVector(8, numElems, 8);\n}\n\nstatic addM(builder:flatbuffers.Builder, mOffset:flatbuffers.Offset) {\n  builder.addFieldOffset(3, mOffset, 0);\n}\n\nstatic createMVector(builder:flatbuffers.Builder, data:number[]|Float64Array):flatbuffers.Offset;\n/**\n * @deprecated This Uint8Array overload will be removed in the future.\n */\nstatic createMVector(builder:flatbuffers.Builder, data:number[]|Uint8Array):flatbuffers.Offset;\nstatic createMVector(builder:flatbuffers.Builder, data:number[]|Float64Array|Uint8Array):flatbuffers.Offset {\n  builder.startVector(8, data.length, 8);\n  for (let i = data.length - 1; i >= 0; i--) {\n    builder.addFloat64(data[i]!);\n  }\n  return builder.endVector();\n}\n\nstatic startMVector(builder:flatbuffers.Builder, numElems:number) {\n  builder.startVector(8, numElems, 8);\n}\n\nstatic addT(builder:flatbuffers.Builder, tOffset:flatbuffers.Offset) {\n  builder.addFieldOffset(4, tOffset, 0);\n}\n\nstatic createTVector(builder:flatbuffers.Builder, data:number[]|Float64Array):flatbuffers.Offset;\n/**\n * @deprecated This Uint8Array overload will be removed in the future.\n */\nstatic createTVector(builder:flatbuffers.Builder, data:number[]|Uint8Array):flatbuffers.Offset;\nstatic createTVector(builder:flatbuffers.Builder, data:number[]|Float64Array|Uint8Array):flatbuffers.Offset {\n  builder.startVector(8, data.length, 8);\n  for (let i = data.length - 1; i >= 0; i--) {\n    builder.addFloat64(data[i]!);\n  }\n  return builder.endVector();\n}\n\nstatic startTVector(builder:flatbuffers.Builder, numElems:number) {\n  builder.startVector(8, numElems, 8);\n}\n\nstatic addTm(builder:flatbuffers.Builder, tmOffset:flatbuffers.Offset) {\n  builder.addFieldOffset(5, tmOffset, 0);\n}\n\nstatic createTmVector(builder:flatbuffers.Builder, data:bigint[]):flatbuffers.Offset {\n  builder.startVector(8, data.length, 8);\n  for (let i = data.length - 1; i >= 0; i--) {\n    builder.addInt64(data[i]!);\n  }\n  return builder.endVector();\n}\n\nstatic startTmVector(builder:flatbuffers.Builder, numElems:number) {\n  builder.startVector(8, numElems, 8);\n}\n\nstatic addType(builder:flatbuffers.Builder, type:GeometryType) {\n  builder.addFieldInt8(6, type, GeometryType.Unknown);\n}\n\nstatic addParts(builder:flatbuffers.Builder, partsOffset:flatbuffers.Offset) {\n  builder.addFieldOffset(7, partsOffset, 0);\n}\n\nstatic createPartsVector(builder:flatbuffers.Builder, data:flatbuffers.Offset[]):flatbuffers.Offset {\n  builder.startVector(4, data.length, 4);\n  for (let i = data.length - 1; i >= 0; i--) {\n    builder.addOffset(data[i]!);\n  }\n  return builder.endVector();\n}\n\nstatic startPartsVector(builder:flatbuffers.Builder, numElems:number) {\n  builder.startVector(4, numElems, 4);\n}\n\nstatic endGeometry(builder:flatbuffers.Builder):flatbuffers.Offset {\n  const offset = builder.endObject();\n  return offset;\n}\n\nstatic createGeometry(builder:flatbuffers.Builder, endsOffset:flatbuffers.Offset, xyOffset:flatbuffers.Offset, zOffset:flatbuffers.Offset, mOffset:flatbuffers.Offset, tOffset:flatbuffers.Offset, tmOffset:flatbuffers.Offset, type:GeometryType, partsOffset:flatbuffers.Offset):flatbuffers.Offset {\n  Geometry.startGeometry(builder);\n  Geometry.addEnds(builder, endsOffset);\n  Geometry.addXy(builder, xyOffset);\n  Geometry.addZ(builder, zOffset);\n  Geometry.addM(builder, mOffset);\n  Geometry.addT(builder, tOffset);\n  Geometry.addTm(builder, tmOffset);\n  Geometry.addType(builder, type);\n  Geometry.addParts(builder, partsOffset);\n  return Geometry.endGeometry(builder);\n}\n}\n","// automatically generated by the FlatBuffers compiler, do not modify\n\n/* eslint-disable @typescript-eslint/no-unused-vars, @typescript-eslint/no-explicit-any, @typescript-eslint/no-non-null-assertion */\n\nimport * as flatbuffers from 'flatbuffers';\n\nimport { ColumnType } from '../flat-geobuf/column-type.js';\n\n\nexport class Column {\n  bb: flatbuffers.ByteBuffer|null = null;\n  bb_pos = 0;\n  __init(i:number, bb:flatbuffers.ByteBuffer):Column {\n  this.bb_pos = i;\n  this.bb = bb;\n  return this;\n}\n\nstatic getRootAsColumn(bb:flatbuffers.ByteBuffer, obj?:Column):Column {\n  return (obj || new Column()).__init(bb.readInt32(bb.position()) + bb.position(), bb);\n}\n\nstatic getSizePrefixedRootAsColumn(bb:flatbuffers.ByteBuffer, obj?:Column):Column {\n  bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);\n  return (obj || new Column()).__init(bb.readInt32(bb.position()) + bb.position(), bb);\n}\n\nname():string|null\nname(optionalEncoding:flatbuffers.Encoding):string|Uint8Array|null\nname(optionalEncoding?:any):string|Uint8Array|null {\n  const offset = this.bb!.__offset(this.bb_pos, 4);\n  return offset ? this.bb!.__string(this.bb_pos + offset, optionalEncoding) : null;\n}\n\ntype():ColumnType {\n  const offset = this.bb!.__offset(this.bb_pos, 6);\n  return offset ? this.bb!.readUint8(this.bb_pos + offset) : ColumnType.Byte;\n}\n\ntitle():string|null\ntitle(optionalEncoding:flatbuffers.Encoding):string|Uint8Array|null\ntitle(optionalEncoding?:any):string|Uint8Array|null {\n  const offset = this.bb!.__offset(this.bb_pos, 8);\n  return offset ? this.bb!.__string(this.bb_pos + offset, optionalEncoding) : null;\n}\n\ndescription():string|null\ndescription(optionalEncoding:flatbuffers.Encoding):string|Uint8Array|null\ndescription(optionalEncoding?:any):string|Uint8Array|null {\n  const offset = this.bb!.__offset(this.bb_pos, 10);\n  return offset ? this.bb!.__string(this.bb_pos + offset, optionalEncoding) : null;\n}\n\nwidth():number {\n  const offset = this.bb!.__offset(this.bb_pos, 12);\n  return offset ? this.bb!.readInt32(this.bb_pos + offset) : -1;\n}\n\nprecision():number {\n  const offset = this.bb!.__offset(this.bb_pos, 14);\n  return offset ? this.bb!.readInt32(this.bb_pos + offset) : -1;\n}\n\nscale():number {\n  const offset = this.bb!.__offset(this.bb_pos, 16);\n  return offset ? this.bb!.readInt32(this.bb_pos + offset) : -1;\n}\n\nnullable():boolean {\n  const offset = this.bb!.__offset(this.bb_pos, 18);\n  return offset ? !!this.bb!.readInt8(this.bb_pos + offset) : true;\n}\n\nunique():boolean {\n  const offset = this.bb!.__offset(this.bb_pos, 20);\n  return offset ? !!this.bb!.readInt8(this.bb_pos + offset) : false;\n}\n\nprimaryKey():boolean {\n  const offset = this.bb!.__offset(this.bb_pos, 22);\n  return offset ? !!this.bb!.readInt8(this.bb_pos + offset) : false;\n}\n\nmetadata():string|null\nmetadata(optionalEncoding:flatbuffers.Encoding):string|Uint8Array|null\nmetadata(optionalEncoding?:any):string|Uint8Array|null {\n  const offset = this.bb!.__offset(this.bb_pos, 24);\n  return offset ? this.bb!.__string(this.bb_pos + offset, optionalEncoding) : null;\n}\n\nstatic startColumn(builder:flatbuffers.Builder) {\n  builder.startObject(11);\n}\n\nstatic addName(builder:flatbuffers.Builder, nameOffset:flatbuffers.Offset) {\n  builder.addFieldOffset(0, nameOffset, 0);\n}\n\nstatic addType(builder:flatbuffers.Builder, type:ColumnType) {\n  builder.addFieldInt8(1, type, ColumnType.Byte);\n}\n\nstatic addTitle(builder:flatbuffers.Builder, titleOffset:flatbuffers.Offset) {\n  builder.addFieldOffset(2, titleOffset, 0);\n}\n\nstatic addDescription(builder:flatbuffers.Builder, descriptionOffset:flatbuffers.Offset) {\n  builder.addFieldOffset(3, descriptionOffset, 0);\n}\n\nstatic addWidth(builder:flatbuffers.Builder, width:number) {\n  builder.addFieldInt32(4, width, -1);\n}\n\nstatic addPrecision(builder:flatbuffers.Builder, precision:number) {\n  builder.addFieldInt32(5, precision, -1);\n}\n\nstatic addScale(builder:flatbuffers.Builder, scale:number) {\n  builder.addFieldInt32(6, scale, -1);\n}\n\nstatic addNullable(builder:flatbuffers.Builder, nullable:boolean) {\n  builder.addFieldInt8(7, +nullable, +true);\n}\n\nstatic addUnique(builder:flatbuffers.Builder, unique:boolean) {\n  builder.addFieldInt8(8, +unique, +false);\n}\n\nstatic addPrimaryKey(builder:flatbuffers.Builder, primaryKey:boolean) {\n  builder.addFieldInt8(9, +primaryKey, +false);\n}\n\nstatic addMetadata(builder:flatbuffers.Builder, metadataOffset:flatbuffers.Offset) {\n  builder.addFieldOffset(10, metadataOffset, 0);\n}\n\nstatic endColumn(builder:flatbuffers.Builder):flatbuffers.Offset {\n  const offset = builder.endObject();\n  builder.requiredField(offset, 4) // name\n  return offset;\n}\n\nstatic createColumn(builder:flatbuffers.Builder, nameOffset:flatbuffers.Offset, type:ColumnType, titleOffset:flatbuffers.Offset, descriptionOffset:flatbuffers.Offset, width:number, precision:number, scale:number, nullable:boolean, unique:boolean, primaryKey:boolean, metadataOffset:flatbuffers.Offset):flatbuffers.Offset {\n  Column.startColumn(builder);\n  Column.addName(builder, nameOffset);\n  Column.addType(builder, type);\n  Column.addTitle(builder, titleOffset);\n  Column.addDescription(builder, descriptionOffset);\n  Column.addWidth(builder, width);\n  Column.addPrecision(builder, precision);\n  Column.addScale(builder, scale);\n  Column.addNullable(builder, nullable);\n  Column.addUnique(builder, unique);\n  Column.addPrimaryKey(builder, primaryKey);\n  Column.addMetadata(builder, metadataOffset);\n  return Column.endColumn(builder);\n}\n}\n","// automatically generated by the FlatBuffers compiler, do not modify\n\n/* eslint-disable @typescript-eslint/no-unused-vars, @typescript-eslint/no-explicit-any, @typescript-eslint/no-non-null-assertion */\n\nimport * as flatbuffers from 'flatbuffers';\n\nimport { Column } from '../flat-geobuf/column.js';\nimport { Geometry } from '../flat-geobuf/geometry.js';\n\n\nexport class Feature {\n  bb: flatbuffers.ByteBuffer|null = null;\n  bb_pos = 0;\n  __init(i:number, bb:flatbuffers.ByteBuffer):Feature {\n  this.bb_pos = i;\n  this.bb = bb;\n  return this;\n}\n\nstatic getRootAsFeature(bb:flatbuffers.ByteBuffer, obj?:Feature):Feature {\n  return (obj || new Feature()).__init(bb.readInt32(bb.position()) + bb.position(), bb);\n}\n\nstatic getSizePrefixedRootAsFeature(bb:flatbuffers.ByteBuffer, obj?:Feature):Feature {\n  bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);\n  return (obj || new Feature()).__init(bb.readInt32(bb.position()) + bb.position(), bb);\n}\n\ngeometry(obj?:Geometry):Geometry|null {\n  const offset = this.bb!.__offset(this.bb_pos, 4);\n  return offset ? (obj || new Geometry()).__init(this.bb!.__indirect(this.bb_pos + offset), this.bb!) : null;\n}\n\nproperties(index: number):number|null {\n  const offset = this.bb!.__offset(this.bb_pos, 6);\n  return offset ? this.bb!.readUint8(this.bb!.__vector(this.bb_pos + offset) + index) : 0;\n}\n\npropertiesLength():number {\n  const offset = this.bb!.__offset(this.bb_pos, 6);\n  return offset ? this.bb!.__vector_len(this.bb_pos + offset) : 0;\n}\n\npropertiesArray():Uint8Array|null {\n  const offset = this.bb!.__offset(this.bb_pos, 6);\n  return offset ? new Uint8Array(this.bb!.bytes().buffer, this.bb!.bytes().byteOffset + this.bb!.__vector(this.bb_pos + offset), this.bb!.__vector_len(this.bb_pos + offset)) : null;\n}\n\ncolumns(index: number, obj?:Column):Column|null {\n  const offset = this.bb!.__offset(this.bb_pos, 8);\n  return offset ? (obj || new Column()).__init(this.bb!.__indirect(this.bb!.__vector(this.bb_pos + offset) + index * 4), this.bb!) : null;\n}\n\ncolumnsLength():number {\n  const offset = this.bb!.__offset(this.bb_pos, 8);\n  return offset ? this.bb!.__vector_len(this.bb_pos + offset) : 0;\n}\n\nstatic startFeature(builder:flatbuffers.Builder) {\n  builder.startObject(3);\n}\n\nstatic addGeometry(builder:flatbuffers.Builder, geometryOffset:flatbuffers.Offset) {\n  builder.addFieldOffset(0, geometryOffset, 0);\n}\n\nstatic addProperties(builder:flatbuffers.Builder, propertiesOffset:flatbuffers.Offset) {\n  builder.addFieldOffset(1, propertiesOffset, 0);\n}\n\nstatic createPropertiesVector(builder:flatbuffers.Builder, data:number[]|Uint8Array):flatbuffers.Offset {\n  builder.startVector(1, data.length, 1);\n  for (let i = data.length - 1; i >= 0; i--) {\n    builder.addInt8(data[i]!);\n  }\n  return builder.endVector();\n}\n\nstatic startPropertiesVector(builder:flatbuffers.Builder, numElems:number) {\n  builder.startVector(1, numElems, 1);\n}\n\nstatic addColumns(builder:flatbuffers.Builder, columnsOffset:flatbuffers.Offset) {\n  builder.addFieldOffset(2, columnsOffset, 0);\n}\n\nstatic createColumnsVector(builder:flatbuffers.Builder, data:flatbuffers.Offset[]):flatbuffers.Offset {\n  builder.startVector(4, data.length, 4);\n  for (let i = data.length - 1; i >= 0; i--) {\n    builder.addOffset(data[i]!);\n  }\n  return builder.endVector();\n}\n\nstatic startColumnsVector(builder:flatbuffers.Builder, numElems:number) {\n  builder.startVector(4, numElems, 4);\n}\n\nstatic endFeature(builder:flatbuffers.Builder):flatbuffers.Offset {\n  const offset = builder.endObject();\n  return offset;\n}\n\nstatic finishFeatureBuffer(builder:flatbuffers.Builder, offset:flatbuffers.Offset) {\n  builder.finish(offset);\n}\n\nstatic finishSizePrefixedFeatureBuffer(builder:flatbuffers.Builder, offset:flatbuffers.Offset) {\n  builder.finish(offset, undefined, true);\n}\n\nstatic createFeature(builder:flatbuffers.Builder, geometryOffset:flatbuffers.Offset, propertiesOffset:flatbuffers.Offset, columnsOffset:flatbuffers.Offset):flatbuffers.Offset {\n  Feature.startFeature(builder);\n  Feature.addGeometry(builder, geometryOffset);\n  Feature.addProperties(builder, propertiesOffset);\n  Feature.addColumns(builder, columnsOffset);\n  return Feature.endFeature(builder);\n}\n}\n","export default new Uint8Array(0);\n","import concat from \"./concat\";\nimport empty from \"./empty\";\n\nexport default function() {\n  var that = this, array = that._array.subarray(that._index);\n  return that._source.read().then(function(result) {\n    that._array = empty;\n    that._index = 0;\n    return result.done ? (array.length > 0\n        ? {done: false, value: array}\n        : {done: true, value: undefined})\n        : {done: false, value: concat(array, result.value)};\n  });\n}\n","import empty from \"./empty\";\n\nexport default function(length) {\n  if ((length |= 0) < 0) throw new Error(\"invalid length\");\n  var that = this, index = this._array.length - this._index;\n\n  // If the request fits within the remaining buffer, resolve it immediately.\n  if (this._index + length <= this._array.length) {\n    return Promise.resolve(this._array.subarray(this._index, this._index += length));\n  }\n\n  // Otherwise, read chunks repeatedly until the request is fulfilled.\n  var array = new Uint8Array(length);\n  array.set(this._array.subarray(this._index));\n  return (function read() {\n    return that._source.read().then(function(result) {\n\n      // When done, it’s possible the request wasn’t fully fullfilled!\n      // If so, the pre-allocated array is too big and needs slicing.\n      if (result.done) {\n        that._array = empty;\n        that._index = 0;\n        return index > 0 ? array.subarray(0, index) : null;\n      }\n\n      // If this chunk fulfills the request, return the resulting array.\n      if (index + result.value.length >= length) {\n        that._array = result.value;\n        that._index = length - index;\n        array.set(result.value.subarray(0, length - index), index);\n        return array;\n      }\n\n      // Otherwise copy this chunk into the array, then read the next chunk.\n      array.set(result.value, index);\n      index += result.value.length;\n      return read();\n    });\n  })();\n}\n","export default function() {\n  return this._source.cancel();\n}\n","// automatically generated by the FlatBuffers compiler, do not modify\n\n/* eslint-disable @typescript-eslint/no-unused-vars, @typescript-eslint/no-explicit-any, @typescript-eslint/no-non-null-assertion */\n\nimport * as flatbuffers from 'flatbuffers';\n\nexport class Crs {\n  bb: flatbuffers.ByteBuffer|null = null;\n  bb_pos = 0;\n  __init(i:number, bb:flatbuffers.ByteBuffer):Crs {\n  this.bb_pos = i;\n  this.bb = bb;\n  return this;\n}\n\nstatic getRootAsCrs(bb:flatbuffers.ByteBuffer, obj?:Crs):Crs {\n  return (obj || new Crs()).__init(bb.readInt32(bb.position()) + bb.position(), bb);\n}\n\nstatic getSizePrefixedRootAsCrs(bb:flatbuffers.ByteBuffer, obj?:Crs):Crs {\n  bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);\n  return (obj || new Crs()).__init(bb.readInt32(bb.position()) + bb.position(), bb);\n}\n\norg():string|null\norg(optionalEncoding:flatbuffers.Encoding):string|Uint8Array|null\norg(optionalEncoding?:any):string|Uint8Array|null {\n  const offset = this.bb!.__offset(this.bb_pos, 4);\n  return offset ? this.bb!.__string(this.bb_pos + offset, optionalEncoding) : null;\n}\n\ncode():number {\n  const offset = this.bb!.__offset(this.bb_pos, 6);\n  return offset ? this.bb!.readInt32(this.bb_pos + offset) : 0;\n}\n\nname():string|null\nname(optionalEncoding:flatbuffers.Encoding):string|Uint8Array|null\nname(optionalEncoding?:any):string|Uint8Array|null {\n  const offset = this.bb!.__offset(this.bb_pos, 8);\n  return offset ? this.bb!.__string(this.bb_pos + offset, optionalEncoding) : null;\n}\n\ndescription():string|null\ndescription(optionalEncoding:flatbuffers.Encoding):string|Uint8Array|null\ndescription(optionalEncoding?:any):string|Uint8Array|null {\n  const offset = this.bb!.__offset(this.bb_pos, 10);\n  return offset ? this.bb!.__string(this.bb_pos + offset, optionalEncoding) : null;\n}\n\nwkt():string|null\nwkt(optionalEncoding:flatbuffers.Encoding):string|Uint8Array|null\nwkt(optionalEncoding?:any):string|Uint8Array|null {\n  const offset = this.bb!.__offset(this.bb_pos, 12);\n  return offset ? this.bb!.__string(this.bb_pos + offset, optionalEncoding) : null;\n}\n\ncodeString():string|null\ncodeString(optionalEncoding:flatbuffers.Encoding):string|Uint8Array|null\ncodeString(optionalEncoding?:any):string|Uint8Array|null {\n  const offset = this.bb!.__offset(this.bb_pos, 14);\n  return offset ? this.bb!.__string(this.bb_pos + offset, optionalEncoding) : null;\n}\n\nstatic startCrs(builder:flatbuffers.Builder) {\n  builder.startObject(6);\n}\n\nstatic addOrg(builder:flatbuffers.Builder, orgOffset:flatbuffers.Offset) {\n  builder.addFieldOffset(0, orgOffset, 0);\n}\n\nstatic addCode(builder:flatbuffers.Builder, code:number) {\n  builder.addFieldInt32(1, code, 0);\n}\n\nstatic addName(builder:flatbuffers.Builder, nameOffset:flatbuffers.Offset) {\n  builder.addFieldOffset(2, nameOffset, 0);\n}\n\nstatic addDescription(builder:flatbuffers.Builder, descriptionOffset:flatbuffers.Offset) {\n  builder.addFieldOffset(3, descriptionOffset, 0);\n}\n\nstatic addWkt(builder:flatbuffers.Builder, wktOffset:flatbuffers.Offset) {\n  builder.addFieldOffset(4, wktOffset, 0);\n}\n\nstatic addCodeString(builder:flatbuffers.Builder, codeStringOffset:flatbuffers.Offset) {\n  builder.addFieldOffset(5, codeStringOffset, 0);\n}\n\nstatic endCrs(builder:flatbuffers.Builder):flatbuffers.Offset {\n  const offset = builder.endObject();\n  return offset;\n}\n\nstatic createCrs(builder:flatbuffers.Builder, orgOffset:flatbuffers.Offset, code:number, nameOffset:flatbuffers.Offset, descriptionOffset:flatbuffers.Offset, wktOffset:flatbuffers.Offset, codeStringOffset:flatbuffers.Offset):flatbuffers.Offset {\n  Crs.startCrs(builder);\n  Crs.addOrg(builder, orgOffset);\n  Crs.addCode(builder, code);\n  Crs.addName(builder, nameOffset);\n  Crs.addDescription(builder, descriptionOffset);\n  Crs.addWkt(builder, wktOffset);\n  Crs.addCodeString(builder, codeStringOffset);\n  return Crs.endCrs(builder);\n}\n}\n","// automatically generated by the FlatBuffers compiler, do not modify\n\n/* eslint-disable @typescript-eslint/no-unused-vars, @typescript-eslint/no-explicit-any, @typescript-eslint/no-non-null-assertion */\n\nimport * as flatbuffers from 'flatbuffers';\n\nimport { Column } from '../flat-geobuf/column.js';\nimport { Crs } from '../flat-geobuf/crs.js';\nimport { GeometryType } from '../flat-geobuf/geometry-type.js';\n\n\nexport class Header {\n  bb: flatbuffers.ByteBuffer|null = null;\n  bb_pos = 0;\n  __init(i:number, bb:flatbuffers.ByteBuffer):Header {\n  this.bb_pos = i;\n  this.bb = bb;\n  return this;\n}\n\nstatic getRootAsHeader(bb:flatbuffers.ByteBuffer, obj?:Header):Header {\n  return (obj || new Header()).__init(bb.readInt32(bb.position()) + bb.position(), bb);\n}\n\nstatic getSizePrefixedRootAsHeader(bb:flatbuffers.ByteBuffer, obj?:Header):Header {\n  bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);\n  return (obj || new Header()).__init(bb.readInt32(bb.position()) + bb.position(), bb);\n}\n\nname():string|null\nname(optionalEncoding:flatbuffers.Encoding):string|Uint8Array|null\nname(optionalEncoding?:any):string|Uint8Array|null {\n  const offset = this.bb!.__offset(this.bb_pos, 4);\n  return offset ? this.bb!.__string(this.bb_pos + offset, optionalEncoding) : null;\n}\n\nenvelope(index: number):number|null {\n  const offset = this.bb!.__offset(this.bb_pos, 6);\n  return offset ? this.bb!.readFloat64(this.bb!.__vector(this.bb_pos + offset) + index * 8) : 0;\n}\n\nenvelopeLength():number {\n  const offset = this.bb!.__offset(this.bb_pos, 6);\n  return offset ? this.bb!.__vector_len(this.bb_pos + offset) : 0;\n}\n\nenvelopeArray():Float64Array|null {\n  const offset = this.bb!.__offset(this.bb_pos, 6);\n  return offset ? new Float64Array(this.bb!.bytes().buffer, this.bb!.bytes().byteOffset + this.bb!.__vector(this.bb_pos + offset), this.bb!.__vector_len(this.bb_pos + offset)) : null;\n}\n\ngeometryType():GeometryType {\n  const offset = this.bb!.__offset(this.bb_pos, 8);\n  return offset ? this.bb!.readUint8(this.bb_pos + offset) : GeometryType.Unknown;\n}\n\nhasZ():boolean {\n  const offset = this.bb!.__offset(this.bb_pos, 10);\n  return offset ? !!this.bb!.readInt8(this.bb_pos + offset) : false;\n}\n\nhasM():boolean {\n  const offset = this.bb!.__offset(this.bb_pos, 12);\n  return offset ? !!this.bb!.readInt8(this.bb_pos + offset) : false;\n}\n\nhasT():boolean {\n  const offset = this.bb!.__offset(this.bb_pos, 14);\n  return offset ? !!this.bb!.readInt8(this.bb_pos + offset) : false;\n}\n\nhasTm():boolean {\n  const offset = this.bb!.__offset(this.bb_pos, 16);\n  return offset ? !!this.bb!.readInt8(this.bb_pos + offset) : false;\n}\n\ncolumns(index: number, obj?:Column):Column|null {\n  const offset = this.bb!.__offset(this.bb_pos, 18);\n  return offset ? (obj || new Column()).__init(this.bb!.__indirect(this.bb!.__vector(this.bb_pos + offset) + index * 4), this.bb!) : null;\n}\n\ncolumnsLength():number {\n  const offset = this.bb!.__offset(this.bb_pos, 18);\n  return offset ? this.bb!.__vector_len(this.bb_pos + offset) : 0;\n}\n\nfeaturesCount():bigint {\n  const offset = this.bb!.__offset(this.bb_pos, 20);\n  return offset ? this.bb!.readUint64(this.bb_pos + offset) : BigInt('0');\n}\n\nindexNodeSize():number {\n  const offset = this.bb!.__offset(this.bb_pos, 22);\n  return offset ? this.bb!.readUint16(this.bb_pos + offset) : 16;\n}\n\ncrs(obj?:Crs):Crs|null {\n  const offset = this.bb!.__offset(this.bb_pos, 24);\n  return offset ? (obj || new Crs()).__init(this.bb!.__indirect(this.bb_pos + offset), this.bb!) : null;\n}\n\ntitle():string|null\ntitle(optionalEncoding:flatbuffers.Encoding):string|Uint8Array|null\ntitle(optionalEncoding?:any):string|Uint8Array|null {\n  const offset = this.bb!.__offset(this.bb_pos, 26);\n  return offset ? this.bb!.__string(this.bb_pos + offset, optionalEncoding) : null;\n}\n\ndescription():string|null\ndescription(optionalEncoding:flatbuffers.Encoding):string|Uint8Array|null\ndescription(optionalEncoding?:any):string|Uint8Array|null {\n  const offset = this.bb!.__offset(this.bb_pos, 28);\n  return offset ? this.bb!.__string(this.bb_pos + offset, optionalEncoding) : null;\n}\n\nmetadata():string|null\nmetadata(optionalEncoding:flatbuffers.Encoding):string|Uint8Array|null\nmetadata(optionalEncoding?:any):string|Uint8Array|null {\n  const offset = this.bb!.__offset(this.bb_pos, 30);\n  return offset ? this.bb!.__string(this.bb_pos + offset, optionalEncoding) : null;\n}\n\nstatic startHeader(builder:flatbuffers.Builder) {\n  builder.startObject(14);\n}\n\nstatic addName(builder:flatbuffers.Builder, nameOffset:flatbuffers.Offset) {\n  builder.addFieldOffset(0, nameOffset, 0);\n}\n\nstatic addEnvelope(builder:flatbuffers.Builder, envelopeOffset:flatbuffers.Offset) {\n  builder.addFieldOffset(1, envelopeOffset, 0);\n}\n\nstatic createEnvelopeVector(builder:flatbuffers.Builder, data:number[]|Float64Array):flatbuffers.Offset;\n/**\n * @deprecated This Uint8Array overload will be removed in the future.\n */\nstatic createEnvelopeVector(builder:flatbuffers.Builder, data:number[]|Uint8Array):flatbuffers.Offset;\nstatic createEnvelopeVector(builder:flatbuffers.Builder, data:number[]|Float64Array|Uint8Array):flatbuffers.Offset {\n  builder.startVector(8, data.length, 8);\n  for (let i = data.length - 1; i >= 0; i--) {\n    builder.addFloat64(data[i]!);\n  }\n  return builder.endVector();\n}\n\nstatic startEnvelopeVector(builder:flatbuffers.Builder, numElems:number) {\n  builder.startVector(8, numElems, 8);\n}\n\nstatic addGeometryType(builder:flatbuffers.Builder, geometryType:GeometryType) {\n  builder.addFieldInt8(2, geometryType, GeometryType.Unknown);\n}\n\nstatic addHasZ(builder:flatbuffers.Builder, hasZ:boolean) {\n  builder.addFieldInt8(3, +hasZ, +false);\n}\n\nstatic addHasM(builder:flatbuffers.Builder, hasM:boolean) {\n  builder.addFieldInt8(4, +hasM, +false);\n}\n\nstatic addHasT(builder:flatbuffers.Builder, hasT:boolean) {\n  builder.addFieldInt8(5, +hasT, +false);\n}\n\nstatic addHasTm(builder:flatbuffers.Builder, hasTm:boolean) {\n  builder.addFieldInt8(6, +hasTm, +false);\n}\n\nstatic addColumns(builder:flatbuffers.Builder, columnsOffset:flatbuffers.Offset) {\n  builder.addFieldOffset(7, columnsOffset, 0);\n}\n\nstatic createColumnsVector(builder:flatbuffers.Builder, data:flatbuffers.Offset[]):flatbuffers.Offset {\n  builder.startVector(4, data.length, 4);\n  for (let i = data.length - 1; i >= 0; i--) {\n    builder.addOffset(data[i]!);\n  }\n  return builder.endVector();\n}\n\nstatic startColumnsVector(builder:flatbuffers.Builder, numElems:number) {\n  builder.startVector(4, numElems, 4);\n}\n\nstatic addFeaturesCount(builder:flatbuffers.Builder, featuresCount:bigint) {\n  builder.addFieldInt64(8, featuresCount, BigInt('0'));\n}\n\nstatic addIndexNodeSize(builder:flatbuffers.Builder, indexNodeSize:number) {\n  builder.addFieldInt16(9, indexNodeSize, 16);\n}\n\nstatic addCrs(builder:flatbuffers.Builder, crsOffset:flatbuffers.Offset) {\n  builder.addFieldOffset(10, crsOffset, 0);\n}\n\nstatic addTitle(builder:flatbuffers.Builder, titleOffset:flatbuffers.Offset) {\n  builder.addFieldOffset(11, titleOffset, 0);\n}\n\nstatic addDescription(builder:flatbuffers.Builder, descriptionOffset:flatbuffers.Offset) {\n  builder.addFieldOffset(12, descriptionOffset, 0);\n}\n\nstatic addMetadata(builder:flatbuffers.Builder, metadataOffset:flatbuffers.Offset) {\n  builder.addFieldOffset(13, metadataOffset, 0);\n}\n\nstatic endHeader(builder:flatbuffers.Builder):flatbuffers.Offset {\n  const offset = builder.endObject();\n  return offset;\n}\n\nstatic finishHeaderBuffer(builder:flatbuffers.Builder, offset:flatbuffers.Offset) {\n  builder.finish(offset);\n}\n\nstatic finishSizePrefixedHeaderBuffer(builder:flatbuffers.Builder, offset:flatbuffers.Offset) {\n  builder.finish(offset, undefined, true);\n}\n\n}\n","export default class Config {\n    static global = new Config();\n\n    private _extraRequestThreshold = 256 * 1024;\n\n    /**\n     * Fetch up to this many extra bytes if it will eliminate an extra request\n     */\n    public extraRequestThreshold(): number {\n        return this._extraRequestThreshold;\n    }\n\n    public setExtraRequestThreshold(bytes: number): void {\n        if (bytes < 0) {\n            throw new Error('extraRequestThreshold cannot be negative');\n        }\n        this._extraRequestThreshold = bytes;\n    }\n}\n","import * as flatbuffers from 'flatbuffers';\nimport { Repeater } from '@repeaterjs/repeater';\n\nimport {\n    type Rect,\n    calcTreeSize,\n    DEFAULT_NODE_SIZE,\n    NODE_ITEM_BYTE_LEN,\n    streamSearch,\n} from './packedrtree.js';\nimport { magicbytes, SIZE_PREFIX_LEN } from './constants.js';\nimport Config from './config.js';\nimport type HeaderMeta from './header-meta.js';\nimport { fromByteBuffer } from './header-meta.js';\nimport { Feature } from './flat-geobuf/feature.js';\n\nexport class HttpReader {\n    private headerClient: BufferedHttpRangeClient;\n    public header: HeaderMeta;\n    private headerLength: number;\n    private indexLength: number;\n    private nocache: boolean;\n\n    constructor(\n        headerClient: BufferedHttpRangeClient,\n        header: HeaderMeta,\n        headerLength: number,\n        indexLength: number,\n        nocache: boolean,\n    ) {\n        this.headerClient = headerClient;\n        this.header = header;\n        this.headerLength = headerLength;\n        this.indexLength = indexLength;\n        this.nocache = nocache;\n    }\n\n    // Fetch the header, preparing the reader to read Feature data.\n    //\n    // and potentially some opportunistic fetching of the index.\n    static async open(url: string, nocache: boolean): Promise<HttpReader> {\n        // In reality, the header is probably less than half this size, but\n        // better to overshoot and fetch an extra kb rather than have to issue\n        // a second request.\n        const assumedHeaderLength = 2024;\n\n        const headerClient = new BufferedHttpRangeClient(url, nocache);\n\n        // Immediately following the header is the optional spatial index, we deliberately fetch\n        // a small part of that to skip subsequent requests.\n        const assumedIndexLength = (() => {\n            // The actual branching factor will be in the header, but since we\n            // don't have the header yet, we just guess. The consequence of\n            // getting this wrong isn't terminal, it only means we may be\n            // fetching slightly more than we need or that we need to make an\n            // extra request later.\n            const assumedBranchingFactor = DEFAULT_NODE_SIZE;\n\n            // NOTE: each layer is exponentially larger\n            const prefetchedLayers = 3;\n\n            let result = 0;\n            let i: number;\n            for (i = 0; i < prefetchedLayers; i++) {\n                const layer_width =\n                    assumedBranchingFactor ** i * NODE_ITEM_BYTE_LEN;\n                result += layer_width;\n            }\n            return result;\n        })();\n\n        const minReqLength = assumedHeaderLength + assumedIndexLength;\n        console.debug(\n            `fetching header. minReqLength: ${minReqLength} (assumedHeaderLength: ${assumedHeaderLength}, assumedIndexLength: ${assumedIndexLength})`,\n        );\n\n        {\n            const bytes = new Uint8Array(\n                await headerClient.getRange(0, 8, minReqLength, 'header'),\n            );\n            if (!bytes.subarray(0, 3).every((v, i) => magicbytes[i] === v)) {\n                console.error(`bytes: ${bytes} != ${magicbytes}`);\n                throw new Error('Not a FlatGeobuf file');\n            }\n            console.debug('magic bytes look good');\n        }\n\n        let headerLength: number;\n        {\n            const bytes = await headerClient.getRange(\n                8,\n                4,\n                minReqLength,\n                'header',\n            );\n            headerLength = new DataView(bytes).getUint32(0, true);\n            const HEADER_MAX_BUFFER_SIZE = 1048576 * 10;\n            if (headerLength > HEADER_MAX_BUFFER_SIZE || headerLength < 8) {\n                // minimum size check avoids panic in FlatBuffers header decoding\n                throw new Error('Invalid header size');\n            }\n            console.debug(`headerLength: ${headerLength}`);\n        }\n\n        const bytes = await headerClient.getRange(\n            12,\n            headerLength,\n            minReqLength,\n            'header',\n        );\n        const bb = new flatbuffers.ByteBuffer(new Uint8Array(bytes));\n        const header = fromByteBuffer(bb);\n\n        const indexLength = calcTreeSize(\n            header.featuresCount,\n            header.indexNodeSize,\n        );\n\n        console.debug('completed: opening http reader');\n        return new HttpReader(\n            headerClient,\n            header,\n            headerLength,\n            indexLength,\n            nocache,\n        );\n    }\n\n    async *selectBbox(rect: Rect): AsyncGenerator<Feature, void, unknown> {\n        // Read R-Tree index and build filter for features within bbox\n        const lengthBeforeTree = this.lengthBeforeTree();\n\n        const bufferedClient = this.headerClient;\n        const readNode = async function (\n            offsetIntoTree: number,\n            size: number,\n        ): Promise<ArrayBuffer> {\n            const minReqLength = 0;\n            return bufferedClient.getRange(\n                lengthBeforeTree + offsetIntoTree,\n                size,\n                minReqLength,\n                'index',\n            );\n        };\n\n        const batches: [number, number][][] = [];\n        let currentBatch: [number, number][] = [];\n        for await (const searchResult of streamSearch(\n            this.header.featuresCount,\n            this.header.indexNodeSize,\n            rect,\n            readNode,\n        )) {\n            const [featureOffset, ,] = searchResult;\n            let [, , featureLength] = searchResult;\n            if (!featureLength) {\n                console.info('final feature');\n                // Normally we get the feature length by subtracting between\n                // adjacent nodes from the index, which we can't do for the\n                // _very_ last feature in a dataset.\n                //\n                // We could *guess* the size, but we'd risk overshooting the length,\n                // which will cause some webservers to return HTTP 416: Unsatisfiable range\n                //\n                // So instead we fetch only the final features byte length, stored in the\n                // first 4 bytes.\n                featureLength = 4;\n            }\n\n            if (currentBatch.length == 0) {\n                currentBatch.push([featureOffset, featureLength]);\n                continue;\n            }\n\n            const prevFeature = currentBatch[currentBatch.length - 1];\n            const gap = featureOffset - (prevFeature[0] + prevFeature[1]);\n            if (gap > Config.global.extraRequestThreshold()) {\n                console.info(\n                    `Pushing new feature batch, since gap ${gap} was too large`,\n                );\n                batches.push(currentBatch);\n                currentBatch = [];\n            }\n\n            currentBatch.push([featureOffset, featureLength]);\n        }\n        this.headerClient.logUsage('header+index');\n        if (currentBatch.length > 0) {\n            batches.push(currentBatch);\n        }\n\n        const promises: AsyncGenerator<Feature, any, any>[] = batches.flatMap(\n            (batch: [number, number][]) =>\n                this.readFeatureBatch(batch, this.nocache),\n        );\n\n        // Fetch all batches concurrently, yielding features as they become\n        // available, meaning the results may be intermixed.\n        yield* Repeater.merge(promises);\n    }\n\n    lengthBeforeTree(): number {\n        // FGB Layout is: [magicbytes (fixed), headerLength (i32), header (variable), Tree (variable), Features (variable)]\n        return magicbytes.length + SIZE_PREFIX_LEN + this.headerLength;\n    }\n\n    lengthBeforeFeatures(): number {\n        return this.lengthBeforeTree() + this.indexLength;\n    }\n\n    buildFeatureClient(nocache: boolean): BufferedHttpRangeClient {\n        return new BufferedHttpRangeClient(\n            this.headerClient.httpClient,\n            nocache,\n        );\n    }\n\n    /**\n     * Fetch a batch of features in a single request, yielding each Feature\n     *\n     * `batch`: [offset, length] of features in the batch\n     */\n    async *readFeatureBatch(\n        batch: [number, number][],\n        nocache: boolean,\n    ): AsyncGenerator<Feature, void, unknown> {\n        const [firstFeatureOffset] = batch[0];\n        const [lastFeatureOffset, lastFeatureLength] = batch[batch.length - 1];\n\n        const batchStart = firstFeatureOffset;\n        const batchEnd = lastFeatureOffset + lastFeatureLength;\n        const batchSize = batchEnd - batchStart;\n\n        // A new feature client is needed for each batch to own the underlying buffer as features are yielded.\n        const featureClient = this.buildFeatureClient(nocache);\n\n        let minFeatureReqLength = batchSize;\n        for (const [featureOffset] of batch) {\n            yield await this.readFeature(\n                featureClient,\n                featureOffset,\n                minFeatureReqLength,\n            );\n            // Only set minFeatureReqLength for the first request.\n            //\n            // This should only affect a batch that contains the final feature, otherwise\n            // we've calculated `batchSize` to get all the data we need for the batch.\n            // For the very final feature in a dataset, we don't know it's length, so we\n            // will end up executing an extra request for that batch.\n            minFeatureReqLength = 0;\n        }\n        featureClient.logUsage('feature');\n    }\n\n    async readFeature(\n        featureClient: BufferedHttpRangeClient,\n        featureOffset: number,\n        minFeatureReqLength: number,\n    ): Promise<Feature> {\n        const offset = featureOffset + this.lengthBeforeFeatures();\n\n        let featureLength: number;\n        {\n            const bytes = await featureClient.getRange(\n                offset,\n                4,\n                minFeatureReqLength,\n                'feature length',\n            );\n            featureLength = new DataView(bytes).getUint32(0, true);\n        }\n\n        const byteBuffer = await featureClient.getRange(\n            offset + 4,\n            featureLength,\n            minFeatureReqLength,\n            'feature data',\n        );\n        const bytes = new Uint8Array(byteBuffer);\n        const bytesAligned = new Uint8Array(featureLength + SIZE_PREFIX_LEN);\n        bytesAligned.set(bytes, SIZE_PREFIX_LEN);\n        const bb = new flatbuffers.ByteBuffer(bytesAligned);\n        bb.setPosition(SIZE_PREFIX_LEN);\n        return Feature.getRootAsFeature(bb);\n    }\n}\n\nclass BufferedHttpRangeClient {\n    httpClient: HttpRangeClient;\n    bytesEverUsed = 0;\n    bytesEverFetched = 0;\n\n    private buffer: ArrayBuffer = new ArrayBuffer(0);\n\n    // Byte offset of `buffer` with respect to the beginning of the file being\n    // buffered\n    private head = 0;\n\n    constructor(source: string | HttpRangeClient, nocache: boolean) {\n        if (typeof source === 'string') {\n            this.httpClient = new HttpRangeClient(source, nocache);\n        } else if (source instanceof HttpRangeClient) {\n            this.httpClient = source;\n        } else {\n            throw new Error('Unknown source ');\n        }\n    }\n\n    async getRange(\n        start: number,\n        length: number,\n        minReqLength: number,\n        purpose: string,\n    ): Promise<ArrayBuffer> {\n        this.bytesEverUsed += length;\n\n        const start_i = start - this.head;\n        const end_i = start_i + length;\n        if (start_i >= 0 && end_i <= this.buffer.byteLength) {\n            return this.buffer.slice(start_i, end_i);\n        }\n\n        const lengthToFetch = Math.max(length, minReqLength);\n\n        this.bytesEverFetched += lengthToFetch;\n        console.debug(\n            `requesting for new Range: ${start}-${start + lengthToFetch - 1}`,\n        );\n        this.buffer = await this.httpClient.getRange(\n            start,\n            lengthToFetch,\n            purpose,\n        );\n        this.head = start;\n\n        return this.buffer.slice(0, length);\n    }\n\n    logUsage(purpose: string): void {\n        const category = purpose.split(' ')[0];\n        const used = this.bytesEverUsed;\n        const requested = this.bytesEverFetched;\n        const efficiency = ((100.0 * used) / requested).toFixed(2);\n\n        console.info(\n            `${category} bytes used/requested: ${used} / ${requested} = ${efficiency}%`,\n        );\n    }\n}\n\nclass HttpRangeClient {\n    url: string;\n    nocache: boolean;\n    requestsEverMade = 0;\n    bytesEverRequested = 0;\n\n    constructor(url: string, nocache: boolean) {\n        this.url = url;\n        this.nocache = nocache;\n    }\n\n    async getRange(\n        begin: number,\n        length: number,\n        purpose: string,\n    ): Promise<ArrayBuffer> {\n        this.requestsEverMade += 1;\n        this.bytesEverRequested += length;\n\n        const range = `bytes=${begin}-${begin + length - 1}`;\n        console.info(\n            `request: #${this.requestsEverMade}, purpose: ${purpose}), bytes: (this_request: ${length}, ever: ${this.bytesEverRequested}), Range: ${range}`,\n        );\n\n        // TODO: better parallelize requests on Chrome\n        //\n        // Safari and Firefox have no issue performing Range requests\n        // for a resource in parallel, but Chrome will stall a\n        // subsequent request to the resource until it's received the\n        // response headers of the prior request. So, it still allows\n        // some limited parallelization, but it's not ideal.\n        //\n        // This is seemingly an artifact of how Chrome manages caching\n        // and it might differ between platforms. We could work around it\n        // by setting the request header:\n        //\n        //      'Cache-Control': 'no-cache, no-store'\n        //\n        // This allows requests to be fully parallelized in Chrome, but\n        // then Chrome won't cache the response, so it seems not a\n        // great trade-off.\n        //\n        // Another work around would be to make each Range request for\n        // a separate URL by appending something like\n        // `?cache_buster=<range>` to the URL, but then Chrome will\n        // require an additional CORS preflight OPTIONS requests per\n        // Range, which is also not a great trade-off.\n        //\n        // See:\n        // https://bugs.chromium.org/p/chromium/issues/detail?id=969828&q=concurrent%20range%20requests&can=2\n        // https://stackoverflow.com/questions/27513994/chrome-stalls-when-making-multiple-requests-to-same-resource\n        const headers: HeadersInit = {\n            Range: range,\n        };\n        if (this.nocache) headers['Cache-Control'] = 'no-cache, no-store';\n\n        const response = await fetch(this.url, { headers });\n\n        return response.arrayBuffer();\n    }\n}\n"],"sourceRoot":""}